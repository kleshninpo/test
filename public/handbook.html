<!DOCTYPE html>

<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<html>

<body>
  <h1>Обзор основных свойств языка
  </h1>
  <p>
    Этот текст задумывался как краткий справочник по языку Python, снабжённый большим количеством примеров. Несмотря на
    явное указание того, что интерпретатор <code>Python</code> выдаёт в качестве ответа, имеет смысл выполнять указанные
    фрагменты кода в интерпретаторе. Во-первых, вы попробуете проверить собственные гипотезы, которые не нашли отражения
    в тексте, во-вторых — отыщете опечатки.
  </p>
  <p>
    Этот справочник не предназначен для знакомства с программированием "с нуля". Скорее может помочь записать на языке
    <code>Python</code> уже понятные конструкции и познакомить с основными отличиями от Паскаля или Си.
  </p>
  <p>
    Обо всех опечатках, ошибках, неудачных примерах и нелогичной последовательности изложения сообщайте по адресу:
    <code>gusarer@gmail.com</code>
  </p>
  <h2>Какие бывают языки</h2>
  <ul>
    <li><u>Высокоуровневые</u> и <u>низкоуровневые</u>
      <br>
      Текст программы на языке Питон не похож на машинный код, программа не оперирует непосредственно содержимым
      регистров процессора. Его служебные слова — это слова английского языка; язык, с помощью которого записываются
      выражения почти полностью совпадает с принятым в математике алгебраическим языком.
    </li>
    <li><u>Общего назначения</u> и <u>специализированные</u>
      <br>
      На Питоне можно написать графический редактор, вебсайт, программу, обрабатывающую результаты опытов, игру в
      крестики-нолики и многое другое.
    </li>
    <li><u>Интерпретируемые</u> и <u>компилируемые</u>
      <br>
      Программу на Питоне выполняет программа" интерпретатор. Почти для каждой операционной системы и архитектуры
      процессора существует свой интерпретатор, так что текст программы не требуется модифицировать. Правда, из-за
      необходимости обработки интепретатором программа на Питоне работает медленее, чем аналогичная программа на
      компилируемом языке (С + + , Паскаль).
    </li>
  </ul>
  Определение языка включает в себя синтаксические и семантические правила. Первые описывают структуру, вторые — смысл.
  <ul>
    <li>
      <p>Синтаксис — определяет разрешённые конструкции языка</p>
      <br>
      <pre class="python">1x = 6 \# имя переменной не может начинаться с цифры
        Аткрой акно! \# нет таких слов в русском языке
</pre>
      <p>Синтаксические ошибки всегда обнаруживаются до выполнения программы в компилируемых языках. В интепретируемых, как
        правило, на этапе выполнения, но, вообще говоря, бывают и предварительные проверки до выполнения программы
        интерпретатором. Эти ошибки — самые простые.</p>
    </li>
    <li>Статическая семантика — связывает синтаксически верные конструкции общим смыслом
      <pre class="python">x = 6 + 'asd' \# операция не определена для int и string
print(t) \# имя t не определено (не имеет значения)
</pre>
      <p> Такие ошибки обнаруживаются на этапе выполнения программы. Пример программы, которая при разных входных данных либо
        корректно завершается, либо выдаёт сообщение об ошибке:</p>
      <pre class="python">x = int(input())
if x &gt; 1:
    print(5)
else:
    print('asd' // x) # не определена операция деления строки на число
</pre>
    </li>
    <li>
      <p>Самые сложные ошибки возникают, когда программа написана верно в предыдущих двух смыслах, но на некоторых входных
        данных не заканчивает работу или выдаёт неправильный ответ.
      </p>
      <pre class="python">def power(a, n):
    res = 1
    i = 1
    while i &lt; n:
        res = res * a
    return res
</pre>
      <p>В этом примере цикл <code>while</code> никогда не закончит работу, если переданное значение параметра
        <code>n</code> больше <em>1</em>.
      </p>
    </li>
  </ul>
  <h2>Значения в языке Python</h2>
  <ul>
    <li>
      Числа
      <ul class="nestedUl">
        <li>Для хранения целых чисел Python в отличие от большинства языков (C + + , Паскаль) использует всю
          доступную память. Фактически, работа с длинными целыми числами реализована в стандарте языка.
        </li>
        <li>
          Вещественные числа реализованы на основе чисел с плавающей точкой двойной точности — double (64 бита). 1
          бит на знак, 11 бит на показатель экспоненты и 52 бита на значащую часть (мантиссу).
          <p>
            Примеры: <code> 3.0, -123.345, .76543, 23.490e23</code>.
          </p>
        </li>
      </ul>
    </li>
    <li>Логические: <code>True, False</code>. Логический тип на самом деле является лишь подтипом целого, значение
      <code>False</code> соответствует нулю, <code>True</code> — любому ненулевому целому числу.
    </li>
    <li>
      Упорядоченные последовательности
      <ul class="nestedUl">
        <li><b>строки</b>: последовательность литералов (символов). Строковые значения должны быть заключены в
          одинарные и двойные кавычки. Примеры: <code>'a', 'abc', '234g 3654___', "don't"</code>.
        </li>
        <li><b>списки</b>: последовательность произвольных элементов, разделяемых запятыми и взятая в квадратные
          скобки. Пустой список — <code>[]</code>. Примеры: <code>[1, 2, 3], ['Name', 'Surname', 5]</code>.
        </li>
        <li>
          <b>кортежи</b>: последовательность произвольных элементов, разделяемых запятыми, которая может быть
          взята в круглые скобки. Пустой кортеж обязательно должен быть взят в скобки: <code>()</code>, кортеж из
          одного элемента обязательно должен содержать запятую после единственного элемента: <code>(4,)</code>.
          <p>
            Примеры: <code>(2, 3), ('abc', 345)</code>
          </p>
        </li>
      </ul>
    </li>
  </ul>
  <h2>Идентификаторы</h2>
  Идентификатором в Питоне называется последовательность заглавных латинских букв, строчных латинских букв, знаков
  подчёркивания и цифр, начинающаяся не с цифры и отличная от служебного слова.
  <p>
    <b>Служебные слова</b>
    <br>
  </p>
  <table class="normtbl">
    <tbody>
      <tr>
        <td>
          <code>False</code>
        </td>
        <td><code>class</code></td>
        <td><code>finally</code></td>
        <td><code>is</code></td>
        <td><code>return</code></td>
      </tr>
      <tr>
        <td>
          <code>None</code>
        </td>
        <td><code>continue</code></td>
        <td><code>for</code></td>
        <td><code>lambda</code></td>
        <td><code>try</code></td>
      </tr>
      <tr>
        <td>
          <code>True</code>
        </td>
        <td><code>def</code></td>
        <td><code>from</code></td>
        <td><code>nonlocal</code></td>
        <td><code>while</code></td>
      </tr>
      <tr>
        <td>
          <code>and</code>
        </td>
        <td><code>del</code></td>
        <td><code>global</code></td>
        <td><code>not</code></td>
        <td><code>with</code></td>
      </tr>
      <tr>
        <td>
          <code>as</code>
        </td>
        <td><code>elif</code></td>
        <td><code>if</code></td>
        <td><code>or</code></td>
        <td><code>yield</code></td>
      </tr>
      <tr>
        <td>
          <code>assert</code>
        </td>
        <td><code>else</code></td>
        <td><code>import</code></td>
        <td><code>pass</code></td>
        <td></td>
      </tr>
      <tr>
        <td>
          <code>break</code>
        </td>
        <td><code>except</code></td>
        <td><code>in</code></td>
        <td><code>raise</code></td>
        <td>
        </td>
      </tr>
    </tbody>
  </table>
  <p>Идентификаторы чувствительны к регистру: <code>count</code> и <code>Count</code> — разные идентификаторы.</p>
  <br>
  <p>Примеры идентификаторов: max, next, a1, <sub>2</sub>, count, Count, search_appropriate_element</p>
  <h2>Иерархия типов в Питоне</h2>
  <ul>
    <li>
      <b>None</b>
    </li>
    <li>
      <b>Числа</b>
      <ul class="nestedUl">
        <li>Целые</li>
        <li>Вещественные</li>
      </ul>
    </li>
    <li>
      <b>Последовательности</b>
      <ul class="nestedUl">
        <li>Строки</li>
        <li>Списки</li>
        <li>Кортежи</li>
      </ul>
    </li>
    <li>
      <b>Отображения</b>
      <ul class="nestedUl">
        <li>Словари</li>
      </ul>
    </li>
  </ul>
  <h2>Операции и выражения</h2>
  <a id="priority" href="#priority"></a>
  <ul>
    <li>
      <b>Операции с целыми числами</b>
      <ul class="nestedUl">
        <li>унарные арифметические: изменение знака (-)</li>
        <li>бинарные арифметические: сложение (+), вычитание (-), умножение (*), целочисленное деление (//), остаток
          от целочисленного деления (\</li>
        <li>унарные битовые: инверсия (\ )</li>
        <li>бинарные битовые: сдвиг вправо (<em>&gt;&gt;</em>), сдвиг влево (<em>&lt;&lt;</em>), битовое "&lt;И"&gt;
          (&amp;), битовое "&lt;ИСКЛЮЧАЮЩЕЕ ИЛИ"&gt; (<em></em>), битовое "&lt;ИЛИ"&gt; (<em>|</em>)</li>
      </ul>
    </li>
    <li>
      <b>Операции с вещественными числами</b>
      <p>
        те же, что и арифметические операции для целых чисел, но вещественное деление обозначается иначе
        (<code>/</code>), а остаток от деления (\
      </p>
      <pre class="python">print(3.14159 % 2)   # результат вычисления равен 1.14159, т.к. 1.14159, С‚.Рє. 3.1159 = 1 * 2 + 1.14159
print(3.14159 % 1.2) # результат вычисления равен 0.74159, т.к. 0.74159, С‚.Рє. 3.14159 = 2 * 1.2 + 0.74159
</pre>
    </li>
    <li>
      <b>Логические операции</b>
      <ul class="nestedUl">
        <li>
          бинарная операция логическое "&lt;И"&gt; (and): результат выполнения равен <code>True</code> тогда и
          только тогда, когда оба операнда равны <code>True</code>, в противном случае результат выполнения равен
          <code>False</code>.
        </li>
        <li>
          бинарная операция логическое "&lt;ИЛИ"&gt; (or): результат выполнения равен <code>True</code> тогда и
          только тогда, когда хотя бы один операнд равен <code>True</code>, в противном случае результат
          выполнения равен <code>False</code>.
        </li>
        <li>
          унарная операция логическое "&lt;НЕ"&gt; (not): результат выполнения равен <code>True</code>, если
          операнд равен <code>False</code>, в противном случае результат выполнения равен <code>True</code>.
        </li>
      </ul>
    </li>
  </ul>
  <p>
    <b>Числовые выражения</b> в Питоне конструируются при помощи числовых значений, идентификаторов, знаков операций и
    круглых скобок в принятом в алгебре порядке. <br>
    Примеры:
  </p>
  <pre class="python">print(123 // 3 // 4 + 5 % 7)    # значение этого выражения - целое число (15),
        # т.к. все операнды - целые,
        # и результат всех промежуточных операций - тоже целое число
print((a + b) * (a - b))        # если хотя бы одно значение (a или b) - вещественное число,
        # то результат - вещественное число, иначе - целое число
print(-c // (a + b) * (a - b))  # то же, что и в предыдущем случае

# в этом примере результат будет в любом случае вещественным числом,
# т.к. последней выполняется операция вещественного деления ( / )
print((dist1 + dist2 + dist3) / (time1 + time2 + time3))
</pre>
  <p>
    К значениям числовых типов можно применять операции сравнения, результатом выполнения которой является значение
    логического типа:
  </p>
  <table class="normtbl">
    <tbody>
      <tr>
        <td>
          Операция
        </td>
        <td> Описание</td>
      </tr>
      <tr>
        <td>
          <code>&lt;</code>
        </td>
        <td> строго меньше</td>
      </tr>
      <tr>
        <td>
          <code>&lt;=</code>
        </td>
        <td> меньше или равно</td>
      </tr>
      <tr>
        <td>
          <code>&gt;</code>
        </td>
        <td> строго больше</td>
      </tr>
      <tr>
        <td>
          <code>&gt;=</code>
        </td>
        <td> больше или равно</td>
      </tr>
      <tr>
        <td>
          <code>==</code>
        </td>
        <td> равно</td>
      </tr>
      <tr>
        <td>
          <code>!=</code>
        </td>
        <td> не равно</td>
      </tr>
    </tbody>
  </table>
  <p>
    Примеры использования операций сравнения и логических операторов:
  </p>
  <pre class="python">b * b - 4 * a * c &gt;= 0
(x &lt; y) and (x - 4) * (y - 3) &lt;= 25 and y &lt;= 6 - x * x
</pre>
  <p>
    Сравнения можно объединять в цепочки. Например, запись <code>a&lt;b&lt;c</code> разрешена синтаксисом языка Python и
    имеет общепринятый смысл. Такая запись эквивалентна следующей: <code>a&lt;b and b&lt;c</code> с той разницей, что
    <code>b</code> вычисляется <b>один</b> раз. Сравнения выполняются слева направо и если не выполнено хотя бы одно, то
    результат сравнения равен <code>False</code>.
  </p>
  <br>
  <b>Приоритет выполнения операций в выражениях (по убыванию приоритета):</b>
  <br>
  <table class="normtbl">
    <tbody>
      <tr>
        <td>
          Операция
        </td>
        <td> Описание</td>
      </tr>
      <tr>
        <td>
          <code>()</code>
        </td>
        <td> скобки</td>
      </tr>
      <tr>
        <td>
          <code>**</code>
        </td>
        <td> возведение в степень</td>
      </tr>
      <tr>
        <td>
          <code> + x, -x, <em>\sim</em>x</code>
        </td>
        <td> унарный плюс, унарный минус, битовое НЕ</td>
      </tr>
      <tr>
        <td>
          <code> + , -</code>
        </td>
        <td> сложение, вычитание</td>
      </tr>
      <tr>
        <td>
          <code><em>&lt;&lt;, &gt;&gt;</em></code>
        </td>
        <td> битовые сдвиги</td>
      </tr>
      <tr>
        <td>
          <code>&amp;</code>
        </td>
        <td> битовое И</td>
      </tr>
      <tr>
        <td>
          <code>^</code>
        </td>
        <td> битовое исключающее ИЛИ</td>
      </tr>
      <tr>
        <td>
          <code>|</code>
        </td>
        <td> битовое ИЛИ</td>
      </tr>
      <tr>
        <td>
          <code>in, not in, is, is not, &lt;, &lt;=, &gt;,&gt;=,&lt;&gt;, !=,==</code>
        </td>
        <td> проверка на принадлежность, на идентичность, сравнения</td>
      </tr>
      <tr>
        <td>
          <code>not</code>
        </td>
        <td> логическое НЕ</td>
      </tr>
      <tr>
        <td>
          <code>and</code>
        </td>
        <td> логическое И</td>
      </tr>
      <tr>
        <td>
          <code>or</code>
        </td>
        <td> логическое ИЛИ</td>
      </tr>
    </tbody>
  </table>
  <br>
  <p>
    Все операции, имеющие одинаковый приоритет выполняются слева направо. Исключениями являются сравнения (см. цепочки
    сравнений выше) и операция возведения в степень, которая выполняется справа налево. Таким образом
    <code>2**3**2</code> понимается как <code>2**(3**2)</code>.
    <b>Замечания</b>
  </p>
  <ul>
    <li>
      Проверка на равенство для вещественного типа не имеет смысла.
      <p>
        Дело в том, что в отличие от целых чисел, для которых существует (и единственное) разложение по степеням двойки, не
        для всех десятичных дробей существует представление в виде конечной суммы дробей вида
        <em>
          <span style="display: inline-block; vertical-align: middle; padding: 0 5px; text-align: center; white-space: nowrap;">
            <span style="vertical-align: bottom; border-bottom: 1px solid Black; display: block;">1</span>
            <span style="vertical-align: top;">2n</span>
          </span>
        </em>.
      </p>
      <p>
        Например,
        <em>
          <span style="display: inline-block; vertical-align: middle; padding: 0 5px; text-align: center; white-space: nowrap;">
            <span style="vertical-align: bottom; border-bottom: 1px solid Black; display: block;">1</span>
            <span style="vertical-align: top;">7</span>
          </span>=0.00(100)
        </em>
      </p>
      <p>
        Вынужденное отбрасывание старших разрядов (округление) приводит, например, к таким результатам (сравнение <em>\sqrt2 · \sqrt2</em> и <em>2</em>):
      </p>
      <pre class="python">import math
a = math.sqrt(2)
print(a * a == 2) # результат выполнения False
</pre>
    </li>
  </ul>
  <!-- TODO ЗДесь пропущено -->
  <pre class="python">x = 7
x += 2  # увеличение значения переменной x на 2: x = x + 2
x -= 2  # уменьшение значения переменной x на 2:  x = x - 2
x *= 2  # увеличение значения переменной x в 2 раза:  x = x * 2
x //= 2  # уменьшение значения переменной x в 2 раза:  x = x // 2
x /= 2  # вещественное деление
x %= 2  # получение остатка от деления x на 2: x = x % 2
</pre>
  <pre class="python">a = b + 3  # невозможно вычислить значение выражения b + 3, т.к. неизвестно чему равно b
t += 7     # так нельзя, это то же самое, что и t = t + 7, невозможно вычислить t + 7
a = 13
a *= 3     # переменная a теперь имеет значение 39
</pre>
  <pre class="python">x = 3       # значение переменной x равно 3 (целый тип)
x = 5 + x   # значение переменной x равно значению выражения 5 + x
            # переменная x теперь имеет значение 8 (целый тип)
x = x * 2.2 # значение переменной x равно значению выражения x * 2.2
            # переменная x теперь имеет значение 17.6 (вещественный тип)

b = 2
b = b / 3   # значение переменной b равно 0.66 (вещественный тип)

x = 2.6
# сейчас переменная x имеет вещественный тип, её значение равно 2.6
x = (x &gt; 3) and (x * x &lt; 100)
# значение выражения в правой части оператора присваивания,
# а значит и переменная x имеют логический тип и равны False
</pre>
  <pre class="python"># a присваивается значение целого типа (4)
# b присваивается значение строкового типа ('abc')
a, b = 4, 'abc'
# а так можно записать обмен значениями для двух переменных
a, b = b, a
</pre>
  <h2>Приведение числовых типов</h2>
  <p>
    Как <code>Python</code> определяет тип числового выражения, если в таком выражении могут встретиться значения
    и переменные разных типов? Это может быть сделано двумя разными способами — или автоматически (такой способ
    называется неявным приведением типа), или путём явного указания типа, который должен иметь результат вычисления
    выражения.
  </p>
  <ul>
    <li>
      <b>Неявное приведение</b>
      Тип числового выражения определяется типом наиболее "&lt;сложного"&gt; из входящих значений и переменных.
      Числовые типы упорядочены по сложности так: целый &lt; вещественный.
      <p>
        Примеры:
      </p>
      <ul class="nestedUl">
        <li>
          выражения целого типа: целые операнды и операции, результат которых — целое число
          <p>
            <code>1 // 3, 2 * 30, 5 // (5 % 3) </code>
          </p>
        </li>
        <li>
          выражения вещественного типа: содержат по крайней мере один вещественный операнд или операцию, результат которой
          — вещественное число:
          <p>
            <code>1 / 5, 45 % 23 + 0.5, 3 + 6 - 6 / 3</code>
          </p>
        </li>
      </ul>
    </li>
    <li>
      <b>Явное приведение</b>
      <p>
        Для явного приведения выражения к нужному типу необходимо использовать встроенные функции <code>int(),
          float()</code>. Каждая зависит от одного аргумента и переводит его в целый и вещественный тип
        соответственно.
      </p>
      <p>
        Примеры корректных вызовов: <code>int(2 / 2), float(7 // 4)</code>
      </p>
      <p>
        Примеры некорректных вызовов: <code>float(-2 ** 2000)</code>
      </p>
    </li>
  </ul>
  
    <h1>Основные операторы</h1>
    <h2>Оператор присваивания</h2>
    <p>
      Синтаксис оператора присваивания:<br>
      <b> &lt;переменная&gt; &lt;команда присваивания&gt; &lt;выражение&gt; </b>
      <br>
      где <b> &lt;переменная&gt; </b> — идентификатор
      <b> &lt;команда присваивания&gt; </b> — одна из команд <code>=, +=, -=, *=, /=, %=</code>
      <b> &lt;выражение&gt; </b>
      — выражение любого типа.
    </p>
    <p>
      Команды <b>+=, -=, *=, /=, //=, %=</b> являются сокращённой формой записи следующих команд:
    </p>
    <p>
      Оператор присваивания выполняет два действия: сначала вычисляет значение выражения, стоящего в правой части, затем
      связывает имя переменной, стоящей
      в левой части с вычисленным значением. Тип переменной, стоящей в левой части определяется типом вычисленного
      значения.
      До того, как имя переменной было связано с каким-то значением, её нельзя использовать в правой части оператора
      присваивания
    </p>
    <p>
      Оператор присваивания выполняет два действия: сначала вычисляет значение выражения, стоящего в правой части, затем
      связывает имя переменной, стоящей
      в левой части с вычисленным значением. Тип переменной, стоящей в левой части определяется типом вычисленного
      значения.
      <br>
      До того, как имя переменной было связано с каким-то значением, её нельзя использовать в правой части оператора
      присваивания
    </p>
    <h2>Функция <code>print</code></h2>
    <p>
      Синтаксис: <code>print(&lt;выражение&gt;[,&lt;выражение&gt;])</code><br>
      Оператор <code>print</code> выводит на экран вычисленные значения указанных выражений, затем символ окончания строки.
      Если надо вывести значения нескольких выражений в одной строке, их следует перечислить через запятую.
    </p>
    <pre class="python">print(34 / 4)     # результат 8.5
print(34 % 4)     # результат 2
print(34 // 4, 34 % 4)    # результат 8 2
</pre>
    <p>
      По умолчанию функция <code>print</code> переводит курсор в начало следующей строки. Это происходит потому что у функции
      <code>print</code> есть необязательный параметр <code>end</code>, равный по умолчанию символу переноса строки. Функции
      <code>print</code> передать значение этого параметра явно:
    </p>
    <pre class="python">print('quotient:',34 / 4, end='')
print(', remainder:',34 % 4)

# результат выполнения:
quotient:8, remainder:2
</pre>
    <p>
      При выводе нескольких значений функция <code>print</code> разделяет их одним пробелом. Управляет этим необязательный
      параметр <code>sep</code>. По умолчанию его значение равно строке из одного пробела.
      Например:
    </p>
    <pre class="python">a = 4
print('Square of', a, 'is', a * a, '.')  #  результат: Square of 4 is 16.
</pre>
    <p>
      Чтобы избавиться от ненужного пробела перед точкой, нужно воспользоваться параметром <code>sep</code> функции <code>print</code>:
    </p>
    <pre class="python">a = 4
print('Square of ', a, ' is ', a * a, '.', sep = ' ')  #  результат: Square of 4 is 16.
</pre>
    <h2>Форматированный вывод</h2>
    <p>Если программа нетребовательна к формату выводимых значений (например нужно вывести несколько чисел или иных значений,
      разделённых пробелом), разумно пользоваться стандартной функцией <code>print</code>, перечисляя значения через запятую.
      Но часто результат работы программы требуется выводить в строго определённом формате, причём параметров <code>sep</code>
      и <code>end</code> может быть недостаточно. Например при выводе вещественных чисел необходимо точно указать количество
      символов, отводимых под дробную часть. Для этих (и для многих других) целей служит т.н. форматированный вывод.
      Для задания выводимым на экран данным требуемого формата можно использовать функцию <code>print</code> в сочетании с
      методом <code>str.format()</code>:
      <br><code>print(&lt;строка форматирования&gt;.format(&lt;перечень форматируемых выражений&gt;))</code><br>
    </p>
    <p>
      Строка форматирования содержит текст и спецификации формата, взятые в фигурные скобки \ \. Спецификация формата
      может быть пустой, содержать номер выражения из списка форматируемых выражений (которые нумеруются, начиная с нуля)
      или номер выражения со спецификацией формата. Весь текст, находящийся вне этих скобок, выводится без изменений.
      Приведём несколько примеров с результатами вывода:
    </p>
    <pre class="python">a = 3
b = 4
print('{0}{1}{2}'.format(a, b, a * b))
3412   # между спецификациями формата отсутствуют пробелы
print('{0} {1} {2}'.format(a, b, a * b))
3 4 12
print('{}{}{}{}'.format(a, b, b / a))
# ошибка: количество спефикаций формата превышает количество форматируемых выражений
print('a={0}, b={1} a % b = {3}, a // b = {2}'.format(a, b, a // b, a % b))
a = 3, b = 4, a % b = 3, a // b = 0
# можно явно указать соответствие спецификаций выражениям
</pre>
    <p>
      Несколько слов о спецификациях формата для вывода чисел.
      <br>
    </p>
    <p>
      Спецификация формата для вывода целых чисел выглядит так: <br><code>&lt;k&gt;d</code><br> где <code>&lt;k&gt;</code>
      это целое число, обозначающее минимальное количество символов, которое должен занимать вывод значения. Если параметр
      <code>&lt;k&gt;</code> не указан, то вывод будет занимать столько символов, сколько фактически требуется.
      <br>
      Спецификация формата для вывода вещественных чисел:<br> <code>&lt;all&gt;.&lt;fraction&gt;f</code><br> где <code>&lt;fraction&gt;</code>
      — количество символов, отводимое на вывод дробной части числа, <code>&lt;all&gt;</code> — суммарное количество
      символов, отводимое на вывод всего числа, включая десятичную точку и знак.
    </p>
    <p>
      Ниже приведены примеры использования форматированного вывода с комментариями:
    </p>
    <pre class="python">print('{0:d} {1:d}'.format(12, 144))
# на каждое значение отводится столько символов, сколько требуется для вывода
# выводимые числа разделяет один пробел, указанный между спецификациями формата
12 144

print('{0:5d}{1:5d}{2:5d}.format(2, 2 ** 10, 2 ** 20))
# на каждое значение отводится 5 символов, если их хватает
# если не хватает - то столько, сколько надо
# пробелов между выводимыми значениями нет, потому второе и третье "слиплись"
    2 10241048576

print('{0:8d}{1:8d}{2:8d}.format(2, 2 ** 10, 2 ** 20))
# если отвести на каждое значение заведомо достаточное количество символов (здесь 8)
# то результат станет лучше:
       2    1024 1048576

x = 11 / 7
print('{0:5.3f} {1:5.3f} {2:10.5f}'.format(x, x * x, x * x * x))
# на первые два значения отводится 5 знаков на всё значение и 3 знака на дробную часть
# на последнее значение отводится 10 знаков на всё и 5 знаков на дробную часть
1.571 2.469    3.88047

import math
a = math.sqrt(2)
b = math.sqrt(3)
print('a = {0:5.6f}, b = {1:5.6f}'.format(a, b))
# обратите внимание на пробелы, окружающие знаки равенства
a = 1.414214, b = 1.732051

# таблица умножения
for i in range(1, 11):
    for j in range(1, 11):
        print('{0:4d}'.format(i * j), end = '')
    print()
# результат выполнения:
   1   2   3   4   5   6   7   8   9  10
   2   4   6   8  10  12  14  16  18  20
   3   6   9  12  15  18  21  24  27  30
   4   8  12  16  20  24  28  32  36  40
   5  10  15  20  25  30  35  40  45  50
   6  12  18  24  30  36  42  48  54  60
   7  14  21  28  35  42  49  56  63  70
   8  16  24  32  40  48  56  64  72  80
   9  18  27  36  45  54  63  72  81  90
  10  20  30  40  50  60  70  80  90 100
</pre>
    Подробнее про форматированный вывод и все его параметры можно прочитать в соответствующем разделе документации:
    <br>
    <code>http://docs.python.org/3/library/string.html\#format-specification-mini-language</code>
    <h2>Функция ввода: <code>input()</code></h2>
    <table class="normtbl">
      <tbody>
        <tr>
          <td>
            Синтаксис:
          </td>
          <td><code>&lt;имя&gt; = input(&lt;s&gt;)</code>
          </td>
        </tr>
      </tbody>
    </table>
    <br>

    <p>
      Функция <code>input</code> выводит на экран строку &lt;s&gt;, затем считывает введённую пользователем строку и связывает
      <code>&lt;имя&gt;</code> c этим строковым значением. Примеры использования:
    </p>
    <br>
    <pre class="python">d = 4
s = input('number:')
print(d * s)
print(d * int(s))
print(d / float(s))

# вывод программы, если пользователь ввёл строку '2':
'2222'
8
2.0

# вывод программы, если пользователь ввёл строку '3.14'
'3.143.143.143.14'
ValueError: invalid literal for int() with base 10: '3.14'
1.2738853503184713

# вывод программы, если пользователь ввёл строку 'abc':
'abcabcabcabc'
ValueError: invalid literal for int() with base 10: 'abc'
ValueError: could not convert string to float: 'abc'
</pre>
    Если известно что на вход программе будет подано число, можно организовать его ввод следующим образом:
    <pre class="python">x = int(input())     # если на вход подаётся целое число
y = float(input())   # если на вход подаётся вещественное число
</pre>
    <h2>Условный оператор</h2>
    <table class="normtbl codeTable long">
      <tbody>
        <tr>
          <td>
            Сокращённый cинтаксис
          </td>
          <td>Расширенный cинтаксис</td>
          <td>Полный cинтаксис</td>
        </tr>
        <tr>
          <td>
            <pre class="python">
if &lt;условие&gt;:
  &lt;составной оператор&gt;
</pre>
          </td>
          <td>
            <pre class="python">
if &lt;условие&gt;:
  &lt;составной оператор&gt;
else:
  &lt;составной оператор&gt;
</pre>
          </td>
          <td>
            <pre class="python">
if &lt;условие&gt;:
  &lt;составной оператор&gt;
elif &lt;условие&gt;:
  &lt;составной оператор&gt;
...
elif &lt;условие&gt;:
  &lt;составной оператор&gt;
else:
  &lt;составной оператор&gt;
</pre>
          </td>
        </tr>
      </tbody>
    </table>
    где:
    <p>
      <b>&lt;условие&gt;</b> — выражение, имеющее значение логического типа или неявным образом приводимое к нему
    </p>
    <p>
      <b>&lt;составной оператор&gt;</b> — один или несколько операторов языка Питон, называемые телом условного оператора
    </p>
    <br>
    <p>
      Как интерпретатор Python понимает, где заканчивается тело условного оператора? Все строчки, содержащие операторы
      тела начинаются с отступа, который обычно составляет 4 пробела. При этом отступ считается относительно стартовой
      позиции заголовка условного оператора (содержащего служебное слово <code>if</code>). Это же правило распространяется
      на вложенные конструкции:
    </p>
    <pre class="python">
if &lt;условие&gt;:
....&lt;оператор&gt;
    ...
....&lt;оператор&gt;
....if &lt;условие&gt;:
........&lt;оператор&gt;
         ...
........&lt;оператор&gt;
....&lt;оператор&gt; # продолжается выполнение первого условного оператора
    ...
....&lt;оператор&gt;
</pre>
    <p>Проверка условия делается один раз, перед выполнением тела условного оператора. Так, в примере:</p>
    <pre class="python">n = 2
if n &lt; 4:
  n = n * 2
  n = n * 2
print(n)
</pre>
    <p>
      программа выведет 8 (т.е. выполнятся все операторы, составляющие тело оператора <code>if</code>).
      \beginflushleftПример расширенного синтаксиса условного оператора:\endflushleft
    </p>
    <pre class="python"># вывод трёх введённых значений в убывающем порядке
# для вложенных условных операторов отступы отсчитываются от его заголовка
x = input()
y = input()
z = input()
if x &gt; y:
    if y &gt; z:
        print(x, y, z)
    else:
        if x &gt; z:
            print(x, z, y)
        else:
            print(z, x, y)
else:
    if x &gt; z:
        print(y, x, z)
    else:
        if y &gt; z:
            print(y, z, x)
        else:
            print(z, y, x)
</pre>
    <p>
      Условный оператор позволяет избежать выполнения частей программы в зависимости от истинности какого-то логического
      выражения. Таким образом, время выполнения программы, составленной из известных нам операторов ввода-вывода и
      условного остаётся постоянным вне зависимости от объёма входных данных. Каждый оператор выполнится не более одного
      раза.
    </p>
    <h2>Оператор цикла <code>while</code></h2>
    <p>Оператор цикла <code>while</code> имеет два варианта синтаксиса:</p>
    <br>
    <table class="normtbl codeTable textHeader">
      <tbody>
        <tr>
          <th>
            Стандартный cинтаксис
          </th>
          <th>Расширенный cинтаксис</th>
        </tr>
        <tr>
          <td>
            <pre class="python">
while &lt;условие&gt;:
  &lt;составной оператор&gt;
</pre>
          </td>
          <td>
            <pre class="python">
while &lt;условие&gt;:
  &lt;составной оператор&gt;
else:
  &lt;составной оператор&gt;
</pre>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    где:
    <p>
      <b>&lt;условие&gt;</b> — выражение, имеющее значение логического типа
    </p>
    <p>
      <b>&lt;составной оператор&gt;</b> — один или несколько операторов, которые называются телом цикла.
    </p>
    <br>
    <p>
      Однократное выполнение тела цикла называется итерацией цикла. Операторы, составляющие тело цикла, записываются с
      отступом относительно заголовка цикла, аналогично тому, как записывается условный оператор.
    </p>
    <p>
      Тело цикла <code>while</code> выполняется до тех пор, пока значение логического выражения
      <code>&lt;условие&gt;</code> равно <code>True</code>. Таким образом, цикл может выполниться <em>любое</em>
      количество раз, от нуля (если значение логического выражения равно <code>False</code> перед началом выполнения
      цикла) до бесконечности (когда значение логического выражения всегда <code>True</code>).
    </p>
    <p>
      В расширенном синтаксисе оператора <code>while</code>: если значение <code>&lt;условия&gt;</code> стало равным
      <code>False</code> выполняется составной оператор после служебного слова <code>else</code>.
    </p>
    <p>
      Важно понимать, что проверка условия делается всегда <b>перед</b> началом (очередного) выполнения тела цикла. В
      процессе выполнения операторов тела цикла условие не контролируется.
    </p>
    <p>
      Как правило, цикл <code>while</code> используется, когда заранее неизвестно, сколько раз должно выполниться тело
      цикла, зато известно условие, при выполнении которого должен выполняться этот цикл.
    </p>
    <pre class="python"># до окончания выполнения цикла неизвестно, сколько итераций будет выполнено
# здесь мы ждём, пока пользователь не введёт строку 'yes' или строку 'no'
s = input('Enter yes/no:')
while s != 'yes' or s != 'no':
    s = input('Enter yes/no:')
print('thank you, you have entered: ' + s)

# наибольшее целое число, чей квадрат не превосходит x
x = int(input())
res = 0
while (res + 1) * (res + 1) &lt;= x:
    res += 1
print(res)

# ввод последовательности целых чисел, заканчивающейся нулём
# нахождение порядкого номера максимального элемента
k = int(input())
cnt = 1
max = k
max_n = cnt
while k != 0:
    if k &gt; max:
        max = k
        max_n = cnt
    cnt += 1
    k = int(input())
print(max_n)
</pre>
    <pre class="python"># ввод последовательности целых чисел, заканчивающейся нулём
# нахождение среднего арифметического последовательности
k = int(input())
cnt = 0
s = 0
while k != 0:
    s = s + k
    cnt = cnt + 1
    k = int(input())
print(s / cnt)

# определение максимальной цифры в десятичной записи натурального числа
# решение не предполагает предварительного вычисления количества разрядов
# или перевода числа в строковый тип
n = int(input())
mx = n % 10
n //= 10
while n &gt; 0:
    if n % 10 &gt; mx:
        mx = n % 10
    n //= 10
print(mx)
</pre>
    <p>
      Казалось бы, какой смысл в расширенном синтаксисе оператора <code>while</code>? Поместим операторы из части <code>else</code>
      сразу после цикла, и добъёмся ровно такого же поведения программы. Разница станет ясна после знакомства с оператором
      <code>break</code> в параграфе <a href="#break">break</a>.
    </p>
    <h2>Операторы <code>break</code> и <code>continue</code></h2>

    <p>В Python существует два дополнительных способа управлять работой цикла — прерывать выполнение оператора цикла или
      прерывать выполнение текущей итерации.</p>
    <p>
      Первый — это оператор <code>break</code>. Этот оператор прерывает выполнение текущей итерации и выходит цикла, после
      чего программа выполняет следующий после цикла оператор. Условие цикла после выполнения оператора <code>break</code>
      не проверяется. Кроме того, не выполняется и составной оператор, соответствующий <code>else</code> (если он есть).
      Таким образом, оператор <code>break</code> прекращает работу <b>всего</b> оператора цикла.
    </p>
    <p>
      Например:
    </p>
    <pre class="python"># как только сумма введённых пользователем чисел равна нулю
# вывести их количество и значение максимальной (положительной) суммы
k = int(input())
s = 0
maxs = 0
count = 0
while True:
    s += k
    if s &gt; maxs:
        maxs = s
    count += 1
    if s == 0:
        break
    k = int(input())
print(count, maxs)
</pre>
    <p>
      А вот пример использования расширенного синтаксиса оператора <code>while</code>:
    </p>
    <pre class="python"># программа предлагает пользователю угадать число от 1 до 20
# для прекращения работы с программой пользователь может ввести отрицательное число
from random import randint
n = 20
to_be_guessed = randint(1, 20)
guess = 0
while guess != to_be_guessed:
    guess = int(input("New number: "))
    if guess &gt; 0:
        if guess &gt; to_be_guessed:
            print("Number too large")
        else:
            print("Number too small")
    else:
        print("Sorry, that you're giving up!")
        break
else:
    print('Congratulation!')
</pre>
    <p>
      Второй способ — оператор <code>continue</code>. Его отличие от оператора <code>break</code> в том, что, заканчивая
      выполнение текущей итерации, он не завершает выполнение самого цикла, а переходит к проверке его условия. Затем, в
      зависимости от результата проверки, переходит к выполнению следующей итерации.
    </p>
    <pre class="python">x = -50
while x &lt; 50:
    if x == 0:
        continue
    print(1 / x)
</pre>
    <h2>Комментарии</h2>
    <p>Комментариями в Python называются строки или части строк программы, начинающиеся с символа '\#'. Такие строки не
      воспринимаются интерпретатором Python, как команды, а игнорируются. Комментарии используются для описания на
      естественном языке нетривиальных (неочевидных) частей программы.</p>
    <p>
      Ещё один способ повысить читаемость программы — давать переменным имена, отражающие смысл (а иногда и тип) этих
      переменных. Не всегда разумно давать <em>всем</em> переменным длинные, "&lt;говорящие"&gt; названия. Но в любом
      случае стоит комбинировать оба эти метода (комментарии и имена переменных), чтобы программа оставалась понятной вне
      зависимости от времени, прошедшего с момента её написания.
    </p>
    <p>
      Пример:
    </p>
    <pre class="python">k = 2
n = int(input())
while n &gt; 2:
    while (n % k) == 0:  # пока можем делить на k
        print(k, end=' ')     # выписываем
        n = n // k            # и делим
    k = k + 1
</pre>
    <h1> Строки, оператор цикла <code>for</code></h1>
    <p>
      Строками в Python называются упорядоченные последовательности символов.
    </p>
    <h2>Строковые значения</h2>
    <p>
      Строковое значение записывается как последовательность символов, заключённая в одинарные или двойные
      кавычки:
    </p>
    <pre class="python">s = 'abcdefgh'
f = s[2]     # значение переменной f равно 'c'
print(s[0])  # будет выведен символ 'a'
</pre>
    <p>
      Далее в тексте все строковые значения будут браться в кавычки. Фраза <em>переменная a имеет значение
        'qwerty'</em> будет означать, что строка <code>a</code> состоит из символов, стоящих между кавычками. Для
      отдельных символов в Python нет специального типа, как в других языках программирования. Символ в Python —
      строка длины 1.
    </p>
    <h2>Операции со строками</h2>
    <ul>
      <li><b>Ввод строки с клавиатуры</b>
        Ввод строк описан выше, в главе <a href="#input">input</a>.
      </li>
      <li>
        <b>Операция индексирования строки</b>: <br><code>&lt;имя строки&gt;[&lt;выражение целого
          типа&gt;]</code><br>
        <p>
          Выражение в квадратных скобках называется индексом. Символы, составляющие строку нумеруются, начиная
          с нуля.
        </p>
        <p>
          Например:
        </p>
        <pre class="python">s = 'abcdefgh'
f = s[2]     # значение переменной f равно 'c'
print(s[0])  # будет выведен символ 'a'
</pre>
        <p>
          Значение отдельных символов строки менять нельзя, можно только создать новое значение и связать его
          с прежним именем. Эта особенность типа 'строка' называется неизменяемостью (immutable). Примеры:
        </p>
        <pre class="python">s = 'abcdefgh'
s[0] = 'z'      # это ошибка
s = 'zbcdefgh'  # так можно
</pre>
        <p>
          Значение индекса может быть отрицательным. Отрицательные индексы отсчитываются с конца строки в
          обратную сторону (от конца строки к её началу):
        </p>\
        <pre class="python">s = 'abcdefgh'
print(s[-2])  # программа выведет символ 'g'
</pre>
      </li>
      <li>
        <b>Функции <code>ord</code> и <code>chr</code></b>
        <br>
        <p>
          В памяти компьютера символы (и строки из них составленные) хранятся как числа (строки — как
          последовательности чисел). Взаимооднозначное соответствие между символами и числами даётся таблицей,
          которая называется ASCII (<em>American Standard Code for Information Interchange</em>).
        </p>
        <p>
          В таблице 256 пар, исторически же используется только первая половина, содержащая основные символы:
          буквы латинского алфавита (строчные и прописные), цифры, знаки препинания и некоторые другие. Кроме
          перечисленных существуют т.н. управляющие символы с номерами, меньшими 32, которые не отображаются
          на экране.
        </p>
        <p>
          Функция, которая по номеру в таблице возвращает символ, называется <code>chr()</code>, обратная ей —
          <code>ord()</code>. Вот некоторые примеры их использования:
        </p>
        <pre class="python"># программа выводит на экран символы с кодами от 32 до 126
k = 32
while k &lt; 127:
    print(chr(k), end=' ')
    k += 1
</pre>
      </li>
      <li>
        <b>Сравнение символов и строк</b>
        <br>
        <p>
          Сравнение строк, состоящих из одного символа сводится к сравнению целых чисел — кодов этих символов,
          возвращаемых функцией <code>ord()</code>. Сравнение строк, состоящих из б\'ольшего количества
          символов определяется лексикографическим порядком (как в словаре). Формально, лексикографический
          порядок для строк одинаковой длины <code>a</code> и <code>b</code> определяется следующим образом:
          <em></em>a\prec b \Leftrightarrow \exists k&lt; len(a): \forall i&lt;k ord(a[i])=ord(b[i]), ord(a[k]&lt;b[k])<em></em>
        </p>
        <p>
          Для определения лексикографического порядка строк разной длины надо в конец короткой строки мысленно
          дописать символы с кодом, меньшим кода любого возможного символа, затем применить стандартное
          правило.
        </p>
        <pre class="python">print('a' &gt; 'c')      # программа выведет False
print('1' &lt; 'z')      # программа выведет True
print('ab' &lt; 'a')     # программа выведет False
print('cba' &gt; 'abc')  # программа выведет True
print('123' &lt; ' ')    # программа выведет False
print('name' &gt; '')    # программа выведет True (пустая строка меньше любой непустой)

# функция возвращает True, если переданная строка состоит из одного символа-цифры
# и False в противном случае
def isdigit(s):
    if len(s) &gt; 1:
        return False
    else:
        return '0' &lt;= s &lt;= '9'
</pre>
        <p>Также для строк определены сравнения на равенство и неравенство.</p>
      </li>
      <li>
        <b>Конкатенация (сложение) строк, функция <code>len</code></b>
        <p>
          Функция <code>len(&lt;строка&gt;)</code> возвращает неотрицательное целое значение — количество
          символов в строке. Таким образом, операция индексирования, т.е. получения элемента строки
          <code>s</code> по его номеру определена для следующего диапазона значений: <em>[-len(s),
            len(s)-1]</em>. При попытке получить значение символа по индексу, находящемуся вне этого диапазона
          произойдёт ошибка и программа прекратит работу.
        </p>
        <pre class="python">s = 'abcdefgh'
print(s[3])        # 'd'
print(s[-3])       # 'f'
print(s[len(s)])   # ошибка
print(s[-len(s)])  # 'a'
</pre>
        <p>
          Операция сложения, определённая для числовых типов, может использоваться и со значениями строкового
          типа.
        </p>
        <p>
          Результатом сложения является новая строка, длина которой равна сумме длин слагаемых строк и
          составленная из их символов с сохранением порядка следования. Такая строковая операция называется
          <em>конкатенацией</em>.
        </p>
        <pre class="python">name = 'Petya'
sname = 'Petrov'
fname = name + ' ' + sname  # значение переменной fname равно 'Petya Petrov'
print(len(name), len(sname), len(fname))  # будут напечатаны числа 5, 6 и 12
</pre>
      </li>
      <li>
        <b>Умножение строки на целое число</b>
        <p>
          Операция умножения, определённая для числовых типов может использоваться и со значениями строкового
          типа следующим образом:<br>&lt;переменная1&gt; = &lt;переменная2&gt; * &lt;переменная3&gt;<br>
          где <code>&lt;переменая1&gt;</code> и одна из переменных в правой части оператора присваивания —
          переменные строкового типа, а вторая переменная в правой части оператора присваивания — целого типа.
        </p>
        <pre class="python">x = 'a+b+'
s = x * 2  # значение переменной s равно 'a+b+a+b+'
s = 3 * x  # значение переменной s равно 'a+b+a+b+a+b+'
</pre>
      </li>
      <li>
        <b>Явное приведение к строковому типу, функция <code>str()</code></b>
        <p>
          Функция <code>str()</code> определена для аргумента любого типа. Сейчас эта функция интересна в
          связи с переводом в строковый тип числовых значений (целых и вещественных) и значений логического
          типа. Следующие примеры дают представление о принципе работы функции:
        </p>
        <pre class="python"># в каждой строке в комментарии указано значение переменной s после присваивания
k = 57.57
s = str(234)    # '234'
s = str(k)      # '57.57'
s = str(1.0/9)  # '0.111111111111'
s = str(False)  # 'False'
s = '(3 * 4 &lt; ' + str(8) + ') == '+str(3*4&lt;8)  # '(3 * 4 &lt; 8) == False'
# функцию str() без аргументов можно использовать для создания пустой строки
d = str()  # значение d равно ''
</pre>
        <p>
          Функция <code>str()</code> для каждого типа действует по некоторому стандартному правилу. Для
          перевода произвольного значения (например, числового) в строку в соответствии с заданным
          предписанием следует пользоваться форматированным выводом (см. раздел <a href="#formattedoutput">formattedoutput</a>).
        </p>
      </li>
      <li>
        <b>Операция <code>in</code></b>
        <p>
          Для строк определена операция <code>in</code> со следующим синтаксисом:<br><code>&lt;s1&gt; in &lt;s2&gt;</code><br>
          где <code>s1</code> и <code>s2</code> - имена значений строкового типа. Выражение <code>&lt;s1&gt;
            in &lt;s2&gt;</code> имеет логический тип и равно <code>True</code> если строка \texttt&lt;s1&gt;
          целиком входит в строку <code>s2</code>, начиная с какого-то места и <code>False</code> в противном
          случае. Например:
        </p>
        <pre class="python">p = 'abcdef'
f = 'bcd'
print(f in p) # программа выведет True
</pre>
      </li>
      <li>
        <b>Сечения строк</b>
        <p>
          В Python имеется удобное средство получения частей упорядоченных последовательностей, в частности
          строк: <em>срезы (или сечения)</em>. Синтаксис операции: <br><code>s[n: m: k]</code><br> где
          <code>s</code> — имя переменной строкового типа, <code>n</code>, <code>m</code>, <code>k</code> —
          выражения целого типа (<em>k\ne0</em>).
        </p>
        <p>
          Значение указанного выражения составляется из символов с индексами равными <em>x = n + i*k</em>, где
          <em>0 ≤ i &lt; <span style="display: inline-block; vertical-align: middle; padding: 0 5px; text-align: center; white-space: nowrap;"> <span style="vertical-align: bottom; border-bottom: 1px solid Black; display: block;">m-n</span> <span style="vertical-align: top;">k</span> </span></em>, причём в том же порядке, что и в
          строке <code>s</code>.
        </p>
        <p>
          Если внутри квадратных скобок стоит одно двоеточие, то считается, что это двоеточие между первым и
          вторым параметрами (<code>n</code> и <code>m</code>). В этом случае сечение строки —
          подпоследовательность исходной строки начиная с символа с индексом <code>n</code> и заканчивая
          символом с индексом <code>m-1</code>.
        </p>
        <ul class="nestedUl">
          <li>Если не указан первый параметр (начало подстроки), то его значение полагается равным 0</li>
          <li>Если не указан второй параметр (конец подстроки), то он полагается равным <code>len(s)</code></li>
          <li>Если не указан третий параметр (шаг), то он полагается равным 1.</li>
        </ul>
        <p>
          Примеры:
        </p>
        <pre class="python">s = 'abcdefghijklmnopqrstuvwxyz'
s2 = '_'
i = 10
print(s[:])       # 'abcdefghijklmnopqrstuvwxyz'
print(s[20:])     # 'uvwxyz'
print(s[:10])     # 'abcdefghij'
print(s[::2])     # 'acegikmoqsuwy'
print(s[10:13:3]) # 'k'
print(s[::-1])    # zyxwvutsrqponmlkjihgfedcba
print(s[::-2])    # zxvtrpnljhfdb
print(s[5:5])     # ''
print(s[:i] + chr(ord(s[i]) - 32) + s[i+1:])  # 'abcdefghijKlmnopqrstuvwxyz'
s = s[:i] + s2 + s[i+1:]   # изменить символ в строке можно только
                           # заново "собрав" новую строку
print(s)                   # 'abcdefghij_lmnopqrstuvwxyz'
</pre>
        <p>
          В предпоследнем примере используется тот факт, что в ASCII-таблице начало блока прописных латинских
          букв и начало блока строчных латинских букв разделяет 32 символа (прописные идут раньше). Так что
          для получения из любой прописной буквы любой строчной и наоборот достаточно вычесть (или прибавить)
          к коду символа число 32.
        </p>
      </li>
    </ul>
    <h2>Оператор цикла <code>for</code></h2>
    <p>
      В Python кроме цикла <code>while</code> существует ещё одна конструкция, позволяющая многократно повторять
      один и тот же набор операций. Цикл <code>for</code> можно записать разными способами, сейчас нам интересен
      тот вариант, который позволяет перебирать элементы упорядоченных последовательностей, в частности строк.
    </p>
    <p>
      Синтаксис его таков:
    </p>
    <pre class="python">
for &lt;ch&gt; in &lt;str&gt;:
    &lt;составной оператор&gt;
</pre>
    <p>
      где <code>&lt;ch&gt;</code> — имя переменной (которая может не иметь никакого значения к началу выполнения цикла
      <code>for</code>), <code>&lt;str&gt;</code> — выражение строкового типа, <code>&lt;составной оператор&gt;</code>
      — один или более операторов.
    </p>
    <p>
      Цикл выполняется следующим образом: вначале вычисляется значение выражения <code>&lt;str&gt;</code>, если
      его длина больше 0, то символы этого значения перебираются по одному и для каждого значения выполняется тело
      цикла. При этом переменная <code>&lt;ch&gt;</code> принимает последовательно значения всех символов строки
      <code>&lt;str&gt;</code>.
    </p>
    <p>
      Если в теле цикла нет оператора <code>break</code> и не произойдёт никаких ошибок на этапе выполнения, то
      цикл гарантированно выполнится ровно <code>len(str)</code> раз.
      Несколько примеров:
    </p>
    <pre class="python"># подсчёт букв латинского алфавита в строке
s = input('enter s:')
count = 0
for c in s:
    if 'a' &lt;= c &lt;= 'z' or 'A' &lt;= c &lt;= 'Z':
        count += 1
print(count)

# функция without_digits заменяет на пробелы все цифры, входящие в строку
def without_digits(s):
    res = ''
    for c in s:
        if '0' &lt;= c &lt;= '9':
            res = res + ' '
        else:
            res = res + c
    return res
print(without_digits('A1B2C3D4E5F'))  # 'A B C D E F '
</pre>
    <h1>Списки, <code>range</code>, <code>for</code> (продолжение)</h1>
    <p>Списки — это упорядоченный набор значений произвольного типа.</p>
    <h2>Значения списков</h2>
    <p>
      По аналогии со строкой, как последовательностью символов, чьё значение задавалось перечислением этих
      символов, значение списка тоже можно задать перечислением его элементов. Отдельные элементы списка
      разделяются запятой, а весь список заключается в квадратные скобки:
    </p>
    <pre class="python">a = [1, 2, 3, 4]
b = [2.71828, 3.14159, -1]
c = ['Vera', 'Nadezhda', 'Lyubov']
d = [True, False]
f = [1, True, 2.333, 'abcdefgh']

# способы задания пустого списка
z = []
z = list()
# списки могут быть вложенными, т.е. элементом списка может быть другой список
quarters = [['Jan', 'Feb', 'Mar'], ['Apr', 'May', 'Jun'],
            ['Jul', 'Aug', 'Sep'], ['Oct', 'Nov', 'Dec']]
</pre>
    <h2>Операции со списками</h2>
    <p>
      Списки можно считать обобщением строк в том смысле, что списки — это тоже упорядоченные последовательности,
      но значения списка могут быть произвольного типа.
      Большинство операций, описанных выше для строк, полностью переносятся на списки:
    </p>
    <ul>
      <li>
        <p>индексирование</p>
        <pre class="python">g = [1, 2, 3, 'February', [6, 7, 8]]
print(g[1])           # программа выведет целое число 2
print(g[len(g) - 1])  # программа выведет список [6, 7, 8]
print(g[-2])          # программа выведет строку 'February'
</pre>
      </li>
      <li>
        <p>конкатенация, умножение на целое число и функция <code>len()</code></p>
        <pre class="python">g = [1, 2, 3]
f = [4, 3, 2]
f = f + g
print(f)           # программа выведет список [4, 3, 2, 1, 2, 3]
print(len(f))      # программа выведет число 6
g = g * 2
print(g)           # программа выведет список [1, 2, 3, 1, 2, 3]
</pre>
      </li>
      <li>
        <p>операция <code>in</code></p>
        <pre class="python">g = [1, 2, 3, 4]
print(1 in g)       # программа выведет True
print([1] in g)     # программа выведет False,
                    # т.к. список g не содержит ни одного элемента типа список
print([1, 2] in g)  # программа выведет False, аналогично предыдущему примеру
</pre>
      </li>
      <li>
        <p>сечения (срезы)</p>
        <pre class="python">t = [4, 6, 8, -1, 4, 5, 9, 12, -7, 0, -3]
print(t[:4])   # [4, 6, 8, -1]
print(t[8:])   # [-7, 0, -3]
print(t[3:5])  # [-1, 4]
print(t[::-2]) # [-3, -7, 9, 4, 8, 4]
</pre>
      </li>
    </ul>
    <p>
      Важное отличие списков от строк заключается в том, что списки можно изменять — как его отдельные элементы,
      так и перечень самих элементов (добавлять, удалять элементы из последовательности и т.п.). Ниже указаны
      некоторые такие операции:
    </p>
    <ul>
      <li>
        изменение элемента списка с заданным индексом:
        <pre class="python">g = [1, 2, 3, 4]
g[1] = 6
print(g) # программа выведет [1, 6, 3, 4]

# содержимое списков можно изменять, используя срезы:
t = [1, 2, 3, 4, 5]
t[2:5] = [5, 4, 3]  # подмножество элементов списка t со 2-го по 4-й
                    # теперь содержит элементы: [5, 4, 3]

print(t)            # а весь список t: [1, 2, 5, 4, 3]
</pre>
        <p>
          Важно понимать разницу между изменением среза и изменением отдельного значения списка. В первом случае
          изменяется некоторое множество элементов списка (возможно, состоящее из одного элемента) и в правой части
          оператора присваивания может быть только последовательность элементов (т.е. или срез какого-то списка или
          весь список). В приведённых ниже примерах (в комментарии к каждой строке кода) указано значение списка
          <code>t</code> после очередной операции присваивания:
        </p>
        <pre class="python">t = [1, 2, 3, 4]
r = [5, 6, 7, 8]
t[1:3] = r[1:3]  # [1, 6, 7, 4]
t[:2] = r[2:]    # [7, 8, 7, 4]
t[:2] = r[3]     # ошибка: попытка присвоить срезу списка t ОДНО значение,
                 # а не последовательность значений
t[1:2] = r[3]    # ошибка: в левой части оператора присваивания по-прежнему срез
                 # хоть и состоящий из одного элемента
q = t[0] + r[:2] # ошибка: пытаясь создать новый список q,
                 # состоящий из нулевого элемента списка t и двух первых элементов
                 # списка r применяем операцию конкатенации
                 # к числу (t[0]) и списку (r[:2])
t[2:3] = r[3:]   # [7, 8, 8, 4]
t[1]= 99         # [7, 99, 8, 4]
t[2] = [9, 6, 7] # [7, 99, [9, 6, 7], 4]

t[len(t) - 1] = t[len(t) - 1:] # [7, 99, [9, 6, 7], [4]]
</pre>
      </li>
      <li>
        <p>
          добавление элемента <code>elem</code> в конец списка <code>t</code>:
          <br>
          <code>t.append(elem)</code>
          <br>
          Пример:
        </p>
        <pre class="python"># программа считывает последовательность чисел указанной длины
# и сохраняет элементы в списке
k = input('k:')
t = []
i = 0
while i &lt; k:
    t = input('element ' + str(i) + ':')
    t.append(t)
    i = i + 1
print(t)
</pre>
        <p>
          Разница между конкатенацией и добавлением элемента следующая: в первом случае это создание нового
          значения и присваивание этого нового значения переменной, во втором случае — это <em>изменение</em>
          текущего значения. Так что конкатенация определена и для строк и для списков, а добавление элемента —
          только для списков.
        </p>
      </li>
      <li>
        <p>удаление последнего элемента списка <code>&lt;t&gt;</code>
          <br>
          <code>&lt;t&gt;.pop()</code>
          <br>
          Операция <code>pop()</code> имеет возвращаемое значение — элемент, который был удалён. Пример
          использования:
        </p>
        <pre class="python"># удаление всех нулевых значений из конца списка
t = [3, 4, 5, 0, 3, 2, 0, 0, 0]
k = len(t) - 1
while k &gt;= 0 and t[k] == 0:
    t.pop()
    k -= 1
print(t)
</pre>
      </li>
    </ul>
    <p>
      Последние две операции несколько отличаются способом записи от изученных до сих пор операций и функций.
      Такие операции называются методами — это функции, применимые к значениям определённого типа. В
      частности, <code>append()</code> и <code>pop()</code> — методы, применимые к спискам. В общем случае
      синтаксис вызова метода таков:
      <br><code>&lt;переменная&gt;.&lt;имя метода&gt;(&lt;перечень аргументов&gt;)</code><br>
    </p>
    <p>
      Можно считать, что метод — это функция, куда неявно передаётся в качестве аргумента <code>&lt;переменная&gt;</code>.
      Такая функция может изменять значение этой переменной и может возвращать значение (как, например, метод
      <code>pop()</code>) или не возвращать, а только изменять передаваемый аргумент (как метод
      <code>append()</code>). Ещё несколько примеров, иллюстрирующих использование <code>append()</code> и
      <code>pop()</code>:
    </p>
    <pre class="python">t = [1, 3, 4, 5, 6, 7]
t.append(99)
print(t)        # программа выведет [1, 3, 4, 5, 6, 7, 99]
print(t.pop())  # программа выведет 99
print(t.pop())  # программа выведет 7
print(t)        # программа выведет [1, 3, 4, 5, 6]
</pre>
    <p>
      В главе <a href="#builtin">builtin</a> будут перечислены основные функции и методы, встроенные в язык
      Python.
    </p>
    <h2>Присваивание и копирование списков</h2>
    <p>
      Следующий фрагмент программы иллюстрирует наиболее сложную для новичков особенность языка Python:
    </p>
    <pre class="python">a = [1, 2, 3]
print(a)  # программа выведет [1, 2, 3]
b = a
a[0] = 99
print(b)  # программа выведет [99, 2, 3], хотя изменяли список a
</pre>
    <p>
      Подробнее об этой особенности изменяемых объектов (и списков в частности) написано в Главе <a href="#dynamictyping">dynamictyping</a>. Кроме того, подробное изложение содержится в \citeLutz,
      глава "&lt;Интерлюдия о динамической типизации"&gt;, параграфы "&lt;Разделяемые ссылки"&gt; и в
      параграфе <a href="#immutable">immutable</a> "&lt;Разделяемые ссылки и изменяемые объекты"&gt;.
    </p>
    <p>
      Здесь лишь приведём два способа сделать копию списка таким образом, чтоб изменения одного не приводили к
      изменению другого.
    </p>
    <pre class="python">a = [1, 2, 3]
print(a)      # программа выведет [1, 2, 3]
x = a[:]      # копия x создана срезом, содержащим ВСЕ элементы списка a
y = list(a)   # копия y создана встроенной функцией list()
a[0] = 99     # изменение "оригинала"
print(x)      # программа выведет [1, 2, 3]
print(y)      # программа выведет [1, 2, 3]
</pre>
    <h2>Функция <code>range</code></h2>
    <p>
      Кроме создания списка перечислением его элементов ещё один способ предоставляет функция
      <code>range</code>. Её синтаксис:
      <br><code>range([start,] stop[,step])</code><br>
    </p>
    <p>
      Параметры <code>start, stop, step</code> — целые числа (<em>step\neq 0</em>).
    </p>
    <p>
      Результат выполнения функции <code>range</code> при положительном (отрицательном) значении параметра
      <code>step</code> — последовательность целых чисел, элементов арифметической прогрессии <em>\a_n\</em> с
      начальным элементом, равным числу <code>start</code>, с разностью <code>step</code> и таких, что <em>start
        ≤ a_i &lt; stop (stop ≤ a_i &lt; start)</em>.
    </p>
    <p>
      Если указаны только два параметра, то считается, что первый — это <code>start</code>, а второй — <code>stop</code>,
      параметр <code>step</code> равен <code>1</code>.
    </p>
    <p>
      Если указан один параметр, считается, что это параметр <code>stop</code>, а параметры <code>start</code>
      и <code>step</code> по умолчанию принимаются равными <code>0</code> и <code>1</code> соответственно.
    </p>
    <p>
      Примеры:
    </p>
    <pre class="python">range(10)         #  последовательность --- [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
range(10, 2)      #  последовательность --- [] # т.к. предполагается, что
                  #  указаны параметры start=10, stop=2, step=1
range(2, 5)       #  последовательность --- [2, 3, 4]
range(3, 20, 2)   #  последовательность --- [3, 5, 7, 9, 11, 13, 15, 17, 19]
range(-5, -2)     #  последовательность --- [-5, -4, -3]
range(1)          #  последовательность --- [0]
range(3, 4, 2)    #  результат --- [3]
range(-1, -1, -7) #  последовательность --- [-1]
range(10, 7, -4)  #  последовательность --- []
range(0, 20, 20)  #  последовательность --- [0]
range(10, 10, 10) #  последовательность --- []
range(13, -4)     #  последовательность --- []
</pre>
    <h2>Оператор цикла <code>for</code></h2>
    <p>
      Цикл <code>for</code>, описанный в параграфе <a href="#stringsFor">stringsFor</a>, работает так же и для
      списков (и строки и списки являются упорядоченными последовательностями).
    </p>
    <pre class="python">
for &lt;elem&gt; in &lt;list&gt;:
    &lt;составной оператор&gt;
</pre>
    <p>
      Необходимо, однако, учитывать, что на разных итерациях цикла переменная <code>&lt;elem&gt;</code> может
      иметь разный тип (список может содержать значения разных типов).
    </p>
    <p>
      Используя функцию <code>range</code> можно создавать список значений цикла <code>for</code> ''на лету''
      и значительно расширить область применения цикла или записывать его короче.
    </p>
    <p>
      В общем случае цикл <code>for</code> работает следующим образом. Сначала вычисляется значение
      последовательности <code>&lt;list&gt;</code>. Если она непуста, то переменной <code>&lt;elem&gt;</code>
      присваивается первое значение из набора (с индексом <em>0</em>). После выполнения тела цикла переменной
      присваивается следующее значение из последовательности. Последний раз тело цикла выполняется при
      значении переменной <code>&lt;elem&gt;</code>, равном последнему элементу последовательности, т.е.
      элементу с номером <code>len(list)-1</code>.
      При помощи функции <code>range()</code> можно формулировать цикл <code>for</code> в терминах индексов
      последовательности (строки, списка), а не самих элементов.
    </p>
    <p>
      Конечно, любой цикл <code>for</code> можно переписать c помощью цикла <code>while</code> и наоборот
      (используя условный оператор и оператор <code>break</code>). Важно научиться понимать, когда удобнее
      использовать ту или иную конструкцию цикла.
    </p>
    <p>
      Цикл <code>for</code> применяется как правило в случае, когда заранее известно количество итераций цикла
      или можно заранее получить элементы списка (или их индексы), значения которых надо перечислить с помощью
      функции <code>range()</code>.
    </p>
    <p>
      Примеры использования:
    </p>
    <pre class="python"># вывод всех целых чисел от a до b включительно
a = int(input())
b = int(input())
for i in range(a, b+1):
    print(i, end = ' ')

# напечатать все нечётные положительные числа, не превосходящие n, в убывающем порядке
n = int(input())
for i in range(n-(n+1)%2, 0, -2):
    print(i, end = ' ')

# вычисление суммы квадратов первых n натуральных чисел
p = 0
for i in range(n):
    p += i * i
print(p)

t = []
for i in range(int(input('k:'))):
    t.append(int(input('element '+str(i)+':'))) # ввод элементов списка

# вычисление суммы элементов списка имеющих чётный индекс
s = 0
for i in range(0, len(t), 2):  # цикл по чётным числам, не превосходящим длину списка
    s += t[i]
print(s)

# пример с чтением k чисел и созданием списка
k = input('k:')
t = []
for i in range(k):
    t = input('element ' + str(i) + ':')
    t.append(t)
print(t)

# то же самое, только короче
t = []
for i in range(int(input('k:'))):
    t.append(int(input('element ' + str(i) + ':')))
print(t)

## использование двух способов записи цикла: while и for
## вычисление минимального положительного элемента списка
k = 0
# ищем первый положительный элемент
while x[k] &lt;= 0:
    k += 1
mn = x[k]

# среди оставшихся ищем минимальный положительный
for i in range(k+1, len(x)):
    if x[i] &gt; 0 and x[i] &lt; mn:
        mn = x[i]

# изменение параметра цикла внутри тела цикла:
# с началом новой итерации параметр всегда получает значение из range
for i in range(5):
    print(i, end = ' ')
    i += 1
    print(i, end = ', ')
# вывод: 0 1, 1 2, 2 3, 3 4, 4 5,
</pre>
    <h2>Функция <code>random</code>. Задание элементов списка случайными числами.</h2>
    <p>
      Функция <code>random()</code> возвращает случайное вещественное число на полуинтервале [0.0, 1.0).
      Функция <code>random()</code> не является стандартной функцией языка Python, для её использования
      необходимо подключить одноимённый модуль <code>random</code> и разрешить использование соответствующей
      функции из него. Делается это такой строчкой:
    </p>
    <pre class="python">
from random import random
</pre>
    <p>
      Эту строчку лучше поместить в первой строчке файла, содержащего программу. Ниже приводится несколько
      примеров использования функции <code>random()</code>:
    </p>
    <pre class="python">from random import random

t = []
# создаём список из 10 случайных вещественных чисел в полуинтервале [0.0, 1.0)
for i in range(10):
    t.append(random())

# то же самое, только одной строчкой
t = [random() for i in range(10)]

# список из 10 случайных целых чисел в полуинтервале [0, 100)
r = [int(random()*100) for i in range(10)]

# список из 10 случайных чётных чисел, принадлежащих отрезку [0, 8]
r = [int(random() * 5) * 2 for i in range(10)]

# пример простого интерфейса
# выбор варианта заполнения списка (случайный, с клавиатуры)
from random import randint

n = int(input('Enter the list length:'))
s = input('(r)andom, (m)anual:')
while not s in ['m','M','r','R']:
    s = input('(r)andom, (m)anual:')
if s == 'm' or s == 'M':
    print('Enter list values (one string)')
    x = [int(input('x[%d]='%i)) for i in range(n)]
else:
    x = [randint(1, 100) for i in range(n)]
print(x)
</pre>
    <h2>Операции с вложенными списками</h2>
    <p>
      Как, используя списки, представить, например, шахматную доску или поле для игры в крестики-нолики?
    </p>
    <p>
      Как мы помним, элементами списка могут быть сами списки. Такие списки называются вложенными.
    </p>
    <p>
      Ниже указан вариант интерпретации поля для игры в крестики-нолики, где пустое поле обозначено нулём,
      крестик числом <em>1</em>, а нолик числом <em>-1</em>. Крестики начинали. Кто выиграл и на каком ходу?
    </p>
    <pre class="python">field = [[1, 0 -1], [-1, 1, -1], [0, 0, 1]]
</pre>
    Каким образом обращаться к элементам вложенных списков?
    <pre class="python">field = [[1, 0 -1], [-1, 1, -1], [0, 0, 1]]
print(field[1])      # элемент списка field с индексом 1 это список [-1, 1, 1]
print(field[1][0])   # а элемент с индексом 0 списка [-1, 1, 1] это число -1
</pre>
    <p>
      Таким образом, если представить, что вложенный список выписывается построчно, то при обращении к
      конкретному элементу сначала указывается индекс строки, а затем индекс столбца.
      Ниже приводятся примеры создания таких списков и их обработки.
    </p>
    <ul>
      <li>
        <b>Считывание вложенного списка</b>
        <p>
          Вводится последовательность строк, содержащих целые числа, разделённые пробелом:
        </p>
        <pre class="python">s = input()
t = []
while s != '':
    t1 = [int(x) for x in s.split()]
    t.append(t1)
    s = input()
print(t)
</pre>
        <p>
          Обратите внимание, что в этом фрагменте совершенно неважно сколько строк и столбцов содержится во
          вводимой таблице. Более того, корректно считается набор с разным количеством чисел в разных строках
          таблицы, например такой:
        </p>
        <pre class="python">
1 2 3
5
3 4 5 66 -9
-5 -6
</pre>
      </li>
      <li>
        <b>Cоздание вложенного списка</b>
        <p>
          Список — квадратная таблица <em>10 × 10</em>, заполненная нулями:
        </p>
        <pre class="python">n = 10
t = [0] * n
x = [t[:] for i in range(n)]
print(x)
# а можно так:
x = [[0 for i in range(10)] for j in range(10)]
print(x)
</pre>
        <p>
          Обратите внимание, что в определении списка <code>x</code> участвует <code>t[:]</code>, т.е. копия
          списка <code>t</code>, а не сам список <code>t</code>. Подробнее о копировании списков см. Главу <a href="#dynamictyping">dynamictyping</a>.
        </p>
      </li>
      <li>
        <b>Заполнение матрицы по шаблону</b>
        <p>
          Как из матрицы слева получить матрицу справа (на главной диагонали, а также двух диагоналях — выше и
          ниже главной стоят единицы)?
        </p>
        <pre class="python">0 0 0 0 0           1 1 0 0 0
0 0 0 0 0           1 1 1 0 0
0 0 0 0 0           0 1 1 1 0
0 0 0 0 0           0 0 1 1 1
0 0 0 0 0           0 0 0 1 1

# предполагаем, что квадратная матрица, заполненная нулями уже дана
# и связана с переменной x
n = 10
t = [0]*n
x = [t[:] for i in range(n)]
print(x)

x[0][0] = 1
for i in range(1, n):
    x[i-1][i], x[i][i], x[i][i-1] = 1, 1, 1

# вывод на экран двумерного списка
for t in x:
    print(' '.join([str(z) for z in t]))
</pre>
      </li>
      <li>
        <b>Проверка квадратной матрицы на симметричность</b>
        <p>
          По окончании вложенного цикла результат вычисления — логическая переменная <code>simm</code> — имеет
          значение <code>True</code>, если матрица симметричная, и <code>False</code> в противном случае.
        </p>
        <p>
          Во вложенном цикле параметр <code>j</code> пробегает значения, начиная с <code>i + 1</code>, а не с
          <code>0</code> и не <code>i</code>.
        </p>
        <pre class="python">N = len(x[0])
simm = True
for i in range(0,N):
    for j in range(i+1, N):
        if x[i][j] != x[j][i]:
            simm = False
            break
    if not simm:
        break
print(simm)
</pre>
      </li>
    </ul>
    <h1>Кортежи</h1>
    <p>
      Кортежи (<code>tuple</code>), как и списки — упорядоченные последовательности элементов произвольной
      природы. Разница лишь в том, эти последовательности <em>неизменяемые</em>. Это означает, что мы не умеем
      добавлять элементы в кортеж, удалять их оттуда и изменять эти элементы. Впрочем, последнее (изменение
      элементов) требует уточнения, которое будет дано ниже.
    </p>
    <h2>Свойства кортежей</h2>
    Итак, основные свойства кортежей:
    <ul>
      <li>
        кортежи — упорядоченные последовательности значений произвольного типа;
      </li>
      <li>
        определена операция индексации, т.е. обращение к элементы кортежа указанием индекса (номера) этого
        элемента в кортеже, причём нумерация, как у всех упорядоченных последовательностей, начинается с
        нуля;
      </li>
      <li>
        кортежи — неизменяемые последовательности, т.е. после создания кортежа нельзя добавлять и удалять
        его элементы, а также изменять их;
      </li>
      <li>
        имеют фиксированную длину и могут иметь любое количество уровней вложенности.
      </li>
    </ul>
    <h2>Значения кортежей</h2>
    <p>Значения кортежей задаются при помощи перечисления через запятую его элементов, взятых в круглые скобки.</p>
    <pre class="python">a = ()                   # пустой кортеж
b = (2, 4)               # кортеж из двух элементов
c = (2, 'spam', -1.678)  # элементы кортежа могут быть разных типов
d = ('abc')              # ! кортеж, состоящий из одного элемента, задаётся не так,
                         # здесь в правой части оператора присваивания
                         # на самом деле стоит ОДНА строка 'abc', взятая в скобки
e = ('abc',)             # а так правильно
                         # обязательна запятая после единственного элемента
f = ((3, 4), [5, 'abc']) # вложенный кортеж - его элементами могут быть любые значения
print(f[1], f[0][1])     # [5, 'abc'] 4
</pre>
    <p>Требование для кортежа из одного элемента содержать запятую возникает оттого, что круглые скобки (в отличие
      от, например, квадратных или фигурных) наделены в синтаксисе языка Python смыслом, не связанным с кортежами
      — они определяют порядок выполнения операций в выражениях. Поэтому выражение, взятое в круглые скобки,
      воспринимается как "&lt;выражение, взятое в круглые скобки"&gt;, а не как последовательность из одного
      элемента.</p>
    <p>
      Создание кортежа из последовательности — строки или списка:
    </p>
    <pre class="python"># описанные ниже операции изменяют объекты --- элементы кортежа,
# потому они запрещены: каждая приводит к ошибке
tpl = ([45, -2, 13, 20], 'list', 4)

tpl[0] = [23, 4]
tpl[1] = 'list example'
tpl[2] = 1 + 3
</pre>
    <h2>Операции c кортежами</h2>
    <ul>
      <li>
        <p>Конкатенация</p>
        <pre class="python">
с = (1, 2) + (3, 4)     # создание нового кортежа: с = (1, 2, 3, 4)
</pre>
      </li>
      <li>
        <p>Умножение на целое число</p>
        <pre class="python">
d = (0, 1) * 3            # d = (0, 1, 0, 1, 0, 1)
</pre>
      </li>
      <li>
        <p>Индексирование и срезы</p>
        <pre class="python">
d = (1, 3, 5, 7, 9)
t = (d[0], d[2:4])      # t = (1, (5, 7))
</pre>
      </li>
      <li>
        <p>[*]Изменение объектов, содержащихся в кортеже</p>
        <p>
          Основное отличие кортежей от списков — невозможность изменять кортежи. Под изменением понимается
          изменение элементов кортежа либо изменение их количества. С изменением количества (добавление,
          удаление) всё понятно, а вот что такое изменение элементов — надо уточнить.
        </p>
        <p>
          В языке Python все типы являются изменяемыми или неизменяемыми. К изменяемым типам из пока
          описанных относится только список (<code>list</code>), к неизменяемым — все числовые типы,
          строки и кортежи.
        </p>
        <pre class="python">g = tuple('abcd')        # результат выполнения: ('a', 'b', 'c', 'd')
g = tuple('abc123')      # результат выполнения: ('a','b','c','1','2','3')
g = tuple([3, 4, 'abc']) # результат выполнения: (3, 4, 'abc')
</pre>
        <p>Но элементы кортежей, которые сами являются изменяемыми объектами (например, списками), изменять
          можно:</p>
        <pre class="python">d = (1, 3, [5, 7])
d[2] = [1, 2]      # Ошибка! нельзя заменять элемент кортежа другим элементом
d[2] = [5, 7]      # и даже так нельзя: списки хоть и содержат одинаковые элементы,
                   # но представляют собой разные объекты (разные области памяти)
d[2][0] = 1        # здесь мы меняем содержимое списка
d[2][1] = 2
print(d)            # (1, 3, [1, 2])
</pre>
      </li>
    </ul>
    <p>
      Подробнее об изменяемых и неизменяемых объектах см. Главу <a href="#dynamictyping">dynamictyping</a>, об
      использовании кортежей в определении функций см. Главу <a href="#functions">functions</a>.
    </p>
    <h2>Применение кортежей</h2>
    <p>Основные преимущества использования кортежей следующие:</p>
    <ul>
      <li>
        множественное присваивание: <code>a, b = b, a</code>
      </li>
      <li>
        кортежи (как неизменяемые объекты, наряду с числами и строками) используются в качестве ключей в
        словарях (см. главу <a href="#dictionary">dictionary</a>);
      </li>
      <li>
        если вы работаете с данными, которые не предполагается изменять в процессе обработки, то
        использование кортежей автоматически защищает их от случайного изменения (и последующего поиска
        ошибки). Примером могут служить алгоритмы вычислительной геометрии, работающие с точками как парами
        их декартовых координат.
      </li>
    </ul>
    <p>
      В отличие от списков, которые являются <em>упорядоченными</em> последовательностями элементов
      произвольного типа, элементы словаря это неупорядоченные последовательности пар <code>(ключ:
        значение)</code>.
    </p>
    <p>
      Иногда словари называют ассоциативными массивами, иногда отображениями (имеется в виду отображение
      множества ключей словаря на множество его значений).
    </p>
    <p>
      Как и списки, словари имеют переменную длину, произвольную вложенность и могут хранить значения
      произвольных типов.
    </p>
    <p>
      Из определения словаря следует, что все операции так или иначе использующие определённый порядок
      следования элементов (индексирование — получение элемента по его номеру, получение среза, конкатенация)
      для словарей не имеют смысла.
    </p>
    <p>
      Как и для всех последовательностей, для словаря определена функция <code>len</code>, возвращающая
      количество пар <code>ключ:значение</code> в словаре.
    </p>
    <h1>Словари</h1>
    <a id="dictionary" href="#dictionary"></a>
    <p>
      В отличие от списков, которые являются <em>упорядоченными</em> последовательностями элементов
      произвольного типа, элементы словаря это неупорядоченные последовательности пар <code>(ключ:
        значение)</code>.
    </p>
    <p>
      Иногда словари называют ассоциативными массивами, иногда отображениями (имеется в виду отображение
      множества ключей словаря на множество его значений).
    </p>
    <p>
      Как и списки, словари имеют переменную длину, произвольную вложенность и могут хранить значения
      произвольных типов.
    </p>
    <p>
      Из определения словаря следует, что все операции так или иначе использующие определённый порядок
      следования элементов (индексирование — получение элемента по его номеру, получение среза, конкатенация)
      для словарей не имеют смысла.
    </p>
    <p>
      Как и для всех последовательностей, для словаря определена функция <code>len</code>, возвращающая
      количество пар <code>ключ:значение</code> в словаре.
    </p>
    <h2>Создание словаря</h2>
    <p>
      Словарь создаётся при помощи фигурных скобок и перечисления пар <code>ключ:значение</code>. В словарях
      существует ограничение на тип ключей — это могут быть только значения неизменяемого типа: целые числа,
      строки и кортежи.
    </p>
    <pre class="python"># пустой словарь
d = {}

# словарь задан перечислением пар ключ:значение
phone = {'Dan': '7926765431', 'John': '74991234567', 'Mary': '79037162534'}

# словарь задан при помощи встроенной функции zip и двух списков: ключей и значений
# функция zip "сшивает" два списка, первый из которых содержит ключи, второй - значения
key_list= ['Dan', 'John', 'Mary', 'Claire']
value_list = ['7926765431', '74991234567', '79037162534', '74957654321']
phone = dict(zip(key_list, value_list))
</pre>
    <h2>Получение значений словаря, изменение словаря</h2>
    <p>
      Создадим словарь:
    </p>
    <pre class="python">phone = {'Dan': '7926765431', 'Mary':' 79037162534'}

print(phone['Dan'])           # 7926765431
print(phone['Mike'])          # Ошибка: KeyError: 'Mike' - такого ключа в словаре нет

if 'Claire' in phone:         # проверка существования ключа Claire в словаре phone
    print(phone['Claire'])
else:
    phone['Claire'] = '74957654321'
print(phone)
# {'Claire': '74957654321', 'Dan': '7926765431', 'Mary': '79037162534'}
# обратите внимание, что порядок пар может не совпадать с заданным при определении
</pre>
    <p>
      Обратите внимание, что оператор вида <code>словарь[ключ] = значение</code> имеет разный смысл в
      зависимости от того, был до этого в словаре такой ключ или нет. В первом случае это изменение значения,
      соответствующего существующему ключу, во втором — создание пары <code>ключ:значение</code>.
      <br>
    </p>
    <pre class="python">
# удаление элемента словаря
del phone['John']            #  удалены ключ и значение 'John': '74991234567'
</pre>
    <p>
      Однако, если удаляемого ключа нет, такой способ приведёт к ошибке. Удалить ключ можно ещё так (ошибки не
      возникнет в любом случае):
    </p>
    <pre class="python">
# безопасное удаление элемента словаря
phone.pop('John', None)
</pre>
    <p>
      Оператор <code>in</code> позволяет проверить наличие ключа (но не значения), методы <code>keys</code> и
      <code>values</code> — получить списки ключей и значений соответственно. Такие списки полезны при
      необходимости дополнительной обработки элементов словаря (ключей, значений). Например, когда надо
      перечислить ключи словаря в определённом порядке.
    </p>
    <p>
      Оператор <code>in</code> позволяет весьма сжато записывать цикл по ключам словаря:
    </p>
    <pre class="python">s = 0
res = {'Dan':5, 'John':4, 'Mary':4, 'Claire':3, 'Maggie':5}
for x in res:
    s += res[x]
print(s / len(res))
</pre>
    <p>
      Другой полезный метод при работе со словарями — метод <code>get(key, default)</code>. Смысл его в
      следующем: при обращении к значению несуществующего ключа можно предусмотреть значение по умолчанию,
      которое можно использовать.
    </p>
    <pre class="python">
res = 'Dan':5, 'John':4, 'Mary':4, 'Claire':3, 'Maggie':5
print(res.get('Dan', 2))      # 5
print(res.get('Mike', 2))     # 2
</pre>
    <h2>Слияние словарей</h2>
    Для словарей определена операция слияния, которая реализована в методе <code>update</code>:
    <pre class="python">
phone1 = 'Dan':'7926765431', 'John':'74881234567'
phone2 = 'Daniel':'7926765431', 'John':'74775566221'
phone1.update(phone2)

print(phone1)
# 'Daniel': '7926765431', 'John': '74775566221', 'Dan': '7926765431'
</pre>
    <p>
      Работает он так: все ключи словаря <code>phone2</code>, которых нет в словаре <code>phone1</code>
      добавляются туда вместе со своими значениями. Значения общих для обоих словарей ключей заменяются на
      значения из словаря <code>phone2</code>.
    </p>
    <p>
      Другие примеры использования словарей:
    </p>
    <pre class="python"># подсчёт количества вхождения разных слов в данной строке
s = input('s:')
d = dict()
for x in s.split():
    if x in d:
        d[x] += 1
    else:
        d[x] = 1
print(d)
</pre>
    <p>
      То же самое можно записать короче, используя метод <code>get</code>:
    </p>
    <pre class="python">s = input('s:')
d = dict()
for x in s.split():
    d[x] = d.get(x, 0) + 1
print(d)

#  s:to be or not to be
#  {'to': 2, 'or': 1, 'not': 1, 'be': 2}
</pre>
    Теперь, если нужно в качестве ключей словаря иметь не слова, а их частоты (количество вхождений), можно "&lt;инвертировать"&gt;
    словарь (ключи — частоты, значения — слова, встречающиеся соответствующее количество раз):
    <pre class="python">def invert_dict(d):
    inv = dict()
    for key in d:
        val = d[key]
        if val not in inv:
            inv[val] = [key]
        else:
            inv[val].append(key)
    return inv

s = input('s:')     # to be or not to be
d = {}
for x in s.split():
    d[x] = d.get(x, 0) + 1
                        # словарь d={'not': 1, 'to': 2, 'or': 1, 'be': 2}
print(invert_dict(d))    # {1: ['not', 'or'], 2: ['to', 'be']}
</pre>
    <h1>Множества</h1>
    <p>
      Множество в языке Python — тип данных в точности совпадающий с одноимённым математическим понятием. Как
      и словарь, множество является неупорядоченной последовательностью элементов. Таким образом, все
      операции, связанные с порядком следования элементов (индексирование, срезы, конкатенация) к множествам
      неприменимы.
    </p>
    <p>
      В языке Python существует две разновидности множеств — изменяемые (<code>set</code>) и неизменяемые
      (<code>frozenset</code>). Подробнее о разнице изменяемых и неизменяемых типов см. параграф <a href="#immutable">immutable</a>.
    </p>
    <h2>Создание множества и логические операции с ними</h2>
    <p>
      Множества создаются так:
    </p>
    <pre class="python">
A = set()           # пустое множество
A =                 # так множество не задают, это пустой словарь
B = 2, 5, 8, 3, 1   # множество задано перечислением своих элементов
</pre>
    <ul>
      <li>
        <p>Проверка на принадлежность элемента множеству</p>
        <pre class="python">
x = 3
y = 89
A = 2, 3, 4, -1
print(x in A)    # True
print(y in A)    # False
</pre>
      </li>
      <li>
        <p>Проверка на отсутствие элемента в множестве</p>
        <pre class="python">
x = 3
y = 4
A = 2, 4, -1
print(x not in A)    # True
print(y not in A)    # False
</pre>
      </li>
      <li>
        <p>Проверка на пустоту пересечения множеств</p>
        <pre class="python">
A = 3, 1, 2
B = 5, 6, 2
C = set()
print(A.isdisjoint(B))    # False
print(C.isdisjoint(B))    # True
</pre>
      </li>
      <li>
        <p>Является ли одно множество подмножеством другого</p>
        <pre class="python">
A = 3, 2, 7
B = 5, 6, 2
C = 3, 2, 4, 5, 6
print(B.issubset(C))      # True
print(B &lt;= C)             # True
print(C.issuperset(C))    # True
print(C &gt;= A)             # False
</pre>
      </li>
      <li>
        <p>Является ли одно множество собственным подмножеством другого</p>
        <pre class="python">
A = 2, 6, 5
B = 5, 6, 2
C = 3, 2, 4, 5, 6
print(A &lt; B)          # False
print(C &gt; B)          # True
</pre>
      </li>
    </ul>
    <h3>Операции над множествами, не приводящие к их изменению</h3>
    <ul>
      <li>
        <p>Объединение двух или нескольких множеств</p>
        <pre class="python">
A = 2, 5
B = 5, 6
C = 3, 2, 4
print(A.union(B))   # 2, 6, 5
print(A)            # 2, 5 множество A при этом не меняется!
print(B | A | C)    # 2, 3, 4, 5, 6
</pre>
      </li>
      <li>
        <p>Пересечение двух или нескольких множеств</p>
        <pre class="python">
A = 2, 5
B = 5, 6
C = 3, 2, 5, 4
print(A.intersection(C))   # 2, 5
print(B &amp; A &amp; C)           # 5
</pre>
      </li>
      <li>
        <p>Разность множеств</p>
        <pre class="python">
A = 1, 2, 3, 4, 5, 6, 7
B = 5, 6
C = 2, 1, 5
print(A.difference(C))   # 3, 4, 6, 7
print(A - B - C)         # 3, 4, 7
</pre>
      </li>
      <li>
        <p>Симметрическая разность множеств</p>
        <pre class="python">
A = 1, 2, 3, 4, 5, 6, 7
B = 2, 6
C = 2, 1, 4, 6, 9, 8
print(A.symmetric_difference(B))   # 1, 3, 4, 5, 7
print(A  C)         # 3, 5, 7, 8, 9
</pre>
      </li>
    </ul>
    <h3>Изменение множеств</h3>
    <ul>
      <li>
        <p>Добавить элемент к множеству</p>
        <pre class="python">
A = 1, 2
A.add(4)
</pre>
      </li>
      <li>
        <p>Удалить элемент из множества</p>
        <pre class="python">
A = 2, 4, 6
A.discard(2)
A.discard(3)
</pre>
        <p>Другой вариант: нельзя удалять отсутствующий в множестве элемент</p>
        <pre class="python">
A = 1, 3, 5
A.remove(5)
A.remove(4)    # ошибка!
</pre>
      </li>
      <li>
        <p>Удалить все элементы множества</p>
        <pre class="python">
A = 5, 1, 6
A.clear()
</pre>
      </li>
      <li>
        <p>Извлечь из непустого множества произвольный элемент и вернуть его значение</p>
        <pre class="python">
A = 1, 2, 3, 4
x = A.pop()
</pre>
      </li>
      <li>
        <p>Добавить к множеству элементы других множеств</p>
        <pre class="python">
A = 5, 1, 6
B = 2
C = 3, 5, 6
D = 8
A |= B      # A = 1, 2, 5, 6, аналог: A.update(B)
A |= C | D  # A = 1, 2, 3, 5, 6, 8, аналог: A.update(C, D)
</pre>
      </li>
      <li>
        <p>Оставить в множестве только элементы, содержащиеся в других множествах</p>
        <pre class="python">
A = 2, 4, 1, 6
B = 3, 4, 1, 5, 6
C = 2, 3, 4, 5, 6, 7
C &amp;= A &amp; B             # 4, 6, аналог: С.intersection_update(A, B)
A &amp;= B                 # 1, 4, 6, аналог: A.intersection_update(B)
</pre>
      </li>
      <li>
        <p>Удалить из множества элементы, содержащиеся в других множествах</p>
        <pre class="python">
A = 1, 2, 3, 4
B = 5, 6, 1
C = 4, 5
A -= B | C   # 2, 3, аналог: A.difference_update(B, C)
</pre>
      </li>
      <li>
        <p>Оставить в множестве элементы, присутствующие в одном из двух, но не обоих множествах</p>
        <pre class="python">
A = 1, 2, 3, 4, 5, 6, 7
B = 2, 4, 8
C = 2, 4, 5, 9
D = 1, 4, 6
A = B     # 1, 3, 5, 6, 7, 8
D = C     # 1, 2, 5, 6, 9
</pre>
      </li>
    </ul>
    <h1>Встроенные функции и методы</h1>
    <a id="builtin" href="#builtin"></a>
    <p>
      Многие из перечисленных в этой главе функций были описаны выше. Тем не менее, здесь даётся их формальное
      определение и примеры их использования. Оригинал на английском языке можно найти здесь:
    </p>
    <br>
    <em>http://docs.python.org/3/library/functions.html</em>
    <p>
      Определения некоторых функций и методов для последовательностей различаются для разных типов, например,
      метод <code>count</code> для списков и строк. Такие определения даны отдельно для каждого типа.
      Некоторые имеют одинаковый смысл, такие, как функции <code>len, sum, all, any</code>. Их описания даны в
      параграфе "&lt;Общие функции"&gt; раздела "&lt;Обработка последовательностей"&gt;.
    </p>
    <p>
      Наконец, в параграфе 'Разные' приведены функции, которые трудно отнести к какому-то определённому типу,
      например, <code>max</code>.
    </p>
    <h2>Числовые функции</h2>
    <ul>
      <li>
        <p>функция <code>round(number[, ndigits])</code></p>
        <p>
          Округляет вещественное число <code>number</code> до <code>ndigits</code> цифр после запятой.
          Если параметр <code>nidigits</code> не указан, то он считается равным <code>0</code> и
          возвращаемое значение имеет целый тип. Если <code>ndigits</code> отрицательное число, то
          округление происходит до <code>|ndigits|</code> знаков <em>до</em> запятой.
        </p>
        <p>
          Результат округления — вещественное число, ближайшее кратное числу
          <em>10<sup>-ndigits</sup></em>.
        </p>
        <p>
          Если результат округления — целое число, равноотстоящие от числа <em>number</em> то результатом
          будет чётное.
        </p>
        <pre class="python">
print(round(3.476))           # 3
print(round(0.5))             # 0
print(round(-0.5))            # 0
print(round(21235.675, -1))   # 21240.0
print(round(2.675, 2))        # 2.67
</pre>
        <p>
          Почему в последней строке результат равен не 2.68? Дело в том, что двоичное представление числа
          2.675 является приближённым и выраженное в десятичной системе счисления равно:
          <br>
          2.67499999999999982236431605997495353221893310546875
        </p>
        <p>
          Чтобы узнать истинное представление вещественного числа, можно воспользоваться функцией <code>Decimal</code>
          из модуля <code>decimal</code>:
        </p>
        <pre class="python">
print(Decimal(44))     # 44  для целых чисел результат равен самому числу
print(Decimal(3.5))    # 3.5  для некоторых вещественных - тоже
print(Decimal(3.55))   # 3.54999999999999982236431605997495353221893310546875
</pre>
      </li>
      <li>
        <p>функция <code>abs(x)</code></p>
        <p>
          Возвращает модуль переданного в качестве параметра числа.
        </p>
        <pre class="python">
print(abs(-3))         # 3
print(abs(0.5))        # 0.5
</pre>
      </li>
      <li>
        <p>функция <code>pow(x, y[, z])</code></p>
        <p>
          Возвращает <em>xy</em>, а если указан параметр <code>z</code>, то <em>xy mod z</em>. Последнее
          вычисляется быстрее, чем
          <code>pow(x, y) </code>.
        </p>
        <p>
          Если <em>y&lt;0</em>, то результат вычисления всегда вещественное число.
        </p>
        <pre class="python">               print(pow(2, 100))   # 1267650600228229401496703205376
               print(pow(1, -0.5))  # 1.0
               print(pow(3, 9, 5))  # 3
               </pre>
      </li>
    </ul>
    <h2>Обработка последовательностей</h2>
    <h3>Общие функции</h3>
    <ul>
      <li>
        <p>функция <code>len(t)</code></p>
        <p>
          Возвращает длину последовательности <code>t</code>, которая может быть строкой, списком,
          кортежем, словарём, множеством.
        </p>
        <pre class="python">
print(len('abcd'))                        # 4
print(len([]))                            # 0
# обратите внимание, как вычисляется len у вложенных последовательностей
print(len((2, 'string', (2, 'tuple'))))   # 3
</pre>
      </li>
      <li>
        <p>функция <code>sum(x[, start])</code></p>
        <p>
          Возвращает сумму элементов последовательности <code>x</code>, сложенную с <code>start</code>:
          <em></em>start + \sumx_i<em></em>Если параметр <code>start</code> не указан, то он считается
          равным нулю.
        </p>
        <pre class="python">
print(sum([12, 34, 56]))                         # 102
print(sum([12, 34, 56], -100))                   # 2, start = -100
# списки тоже умеем складывать, результат - список
print(sum([[1, 1, 1],[1, 0, -1], [0, 1, 1]]))    # ошибка! по умолчанию start=0
                 # списки, содержащиеся в исходном списке
                 # будут прибавляться к нулю, а для целых чисел и списков
                 # операция сложения не определена
print(sum([[1, 1, 1],[1, 0, -1], [0, 1, 1]], []))   # [1, 1, 1, 1, 0, -1, 0, 1, 1]
</pre>
      </li>
      <li>
        <p>функции <code>all(x)</code> и <code>any(x)</code></p>
        <p>
          Функция <code>all</code> возвращает логическое значение <code>True</code>, если все элементы
          последовательности равны <code>True</code> (или последовательность пуста) и <code>False</code> в
          противном случае.
        </p>
        <p>
          Напоминание о приведении типов: к значению <code>True</code> приводятся все отличные от нуля
          числа и любые непустые последовательности, к значению <code>False</code> приводится число нуль и
          все пустые последовательности.
        </p>
        <pre class="python">
print(all([]))             # True (список пуст)
print(all([[]]))           # False (список не пуст, содержит один элемент)
print(all([True, []]))     # False (непустой список,
                          # одно из значений которого равно False)
print(all([(4.5), True]))  # True
print(all(''), all ('ab')) # True, True
</pre>
        <p>
          Функция <code>any</code> возвращает логическое значение <code>True</code>, если хотя бы один
          элемент непустой последовательности равен <code>True</code>. В противном случае, а также если
          последовательность пуста, возвращает <code>False</code>.
        </p>
        <pre class="python">
print(any(''), all ('ab')) # False True
</pre>
      </li>
    </ul>
    <h3>Методы работы со списками</h3>
    <ul>
      <li>
        <p>метод <code>x.count(a)</code></p>
        <p>
          Возвращает количество элементов последовательности <code>x</code>, равных <code>a</code>.
        </p>
        <pre class="python">
print('kldajfhwfgnwegwegvwnrtgh'.count('h'))    # 2
print([[1,2,3], [3], 3].count(3))               # 1
print([[1,2,3], [3], 3].count([3]))             # 1
print(([1,2,3], [3], 3).count([1, 2]))          # 0
</pre>
      </li>
      <li>
        <p>метод <code>x.index(a[, i [, j]])</code></p>
        <p>
          Возвращает индекс первого вхождения элемента <code>a</code> в срез последовательности <code>x[i:
            j]</code>. Иначе говоря, возвращает наименьшее <code>k</code>, такое что <em>x[k] = a, i ≤ k&lt;j</em>.
          Если такого элемента нет, происходит ошибка.
        </p>
        <pre class="python">
print('abcdefgh'.index('f'))       # 5
print('abcdefgh'.index('z'))       # ошибка!
print([1, 2, (3,)].index(2))       # 1
print([1, 2, (3,)].index(3))       # ошибка!
print([1, 2, (3,)].index((3,)))    # 2
print([1, 2, (3,)].index([1, 2]))  # ошибка!
s = 'Happy families are all alike'
print(s.index('i', 7, 20))         # 9
</pre>
      </li>
      <li>
        <p>метод <code>t.append(x)</code></p>
        <p>
          Метод добавляет в конец списка <code>t</code> элемент <code>x</code>. Метод <code>append</code>
          не возвращает значения, только изменяет список <code>t</code>.
        </p>
        <pre class="python">
t = [1, 2, 3]
t.append(5)
print(t)        # [1, 2, 3, 5]
t.append([9])
print(t)        # [1, 2, 3, 5, [9]]
</pre>
      </li>
      <li>
        <p>метод <code>t.insert(i, x)</code></p>
        <p>
          Вставляет элемент <code>x</code> в <code>i</code>-ю позицию списка <code>t</code>. Метод <code>insert</code>
          ничего не возвращает.
        </p>
        <pre class="python">
t = [4, 9, 5, 4, -7, 1]
t.insert(3, 200)
print(t)    # [4, 9, 5, 200, 4, -7, 1]
</pre>
        <p>Действие метода равносильно следующему оператору: <code>t[i:i] = x</code></p>
      </li>
      <li>
        <p>метод <code>t.extend(x)</code></p>
        <p>
          Добавляет список <code>x</code> в конец списка <code>t</code>. Возвращает изменённый список
          <code>t</code>. Действие аналогично операции
          <br>
          <code>t = t + x</code>, но выполняется быстрее конкатенации.
        </p>
        <pre class="python">
t = [4, 9, 4, -7, 1]
t.extend(5)         # ошибка! 5 - число, а не список
t.extend([5, 99])
print(t)            # [4, 9, 4, -7, 1, 5, 99]
</pre>
      </li>
      <li>
        <p>метод <code>t.pop(i)</code></p>
        <p>
          Метод удаляет <code>i</code>-й элемент списка <code>t</code> и возвращает этот элемент.
        </p>
        <pre class="python">
t = [7, 8, 3, 0, 7, -6]
x = t.pop(4)
print(x, t)      # 7 [7, 8, 3, 0, -6]
x = t.pop()
print(x, t)      # -6 [7, 8, 3, 0]
</pre>
        <p>
          Обратите внимание, что параметр <code>i</code> метода <code>pop</code> является необязательным.
          Если он не указан, то считается, что удаляется последний элемент.
        </p>
        <p>
          Если список пуст, произойдёт ошибка.
        </p>
      </li>
      <li>
        <p>оператор <code>del x</code></p>
        <p>
          Действие оператора <code>del</code> такое же, как и метода <code>t.pop(x)</code>, но в отличие
          от метода <code>pop</code> оператор <code>del</code> не возвращает никакого значения.
        </p>
        <pre class="python">
t = [1, 2, 3, 4, 5, 6, 7, 8]
del t[4]
print(t)     # [1, 2, 3, 4, 6, 7, 8]
del t[5:]
print(t)     # [1, 2, 3, 4, 6]
</pre>
      </li>
      <li>
        <p>метод <code>t.remove(x)</code></p>
        <p>
          Удаляет первое вхождение элемента <code>x</code> из списка <code>t</code>. Аналогично операции
          <code>del t[t.index(x)]</code>
        </p>
      </li>
      <li>
        <p>метод <code>t.reverse()</code></p>
        <p>
          Разворачивает список <code>t</code>, меняя порядок следования элементов на противоположный. Не
          возвращает значения.
        </p>
        <pre class="python">
t = [1, 2, 3]
t.reverse()
print(t)     # [3,2,1]
</pre>
      </li>
      <li>
        <p>метод <code>t.sort([cmp[, key[, reverse]]])</code></p>
        <p>
          Метод сортирует список <code>t</code> в порядке возрастания элементов. Параметры
          <code>cmp</code> и <code>key</code> метода <code>sort</code> позволяют определять собственный
          способ сравнения элементов списка, а также, с помощью параметра <code>reverse</code>, получать
          результат в обратном порядке (вместо дополнительного вызова метода <code>reverse()</code>).
          Рассмотрим параметры подробнее:
        </p>
        <ul class="nestedUl">
          <li>
            <p>
              параметр <code>cmp</code>: имя функции от двух параметров, возвращающей отрицательное
              число, нуль или положительное число в зависимости от того, является ли первый параметр
              меньше второго, равен второму, больше второго.
            </p>
            <p>
              Например, мы можем сортировать целые числа по сумме цифр их десятичной записи.
            </p>
          </li>
          <li>
            <p>
              параметр <code>key</code>: имя функции от одного аргумента, которая вызывается перед тем, как
              выполнять сравнение.
            </p>
            <p>
              Такой приём удобен при сортировке последовательностей (строк, кортежей или списков), когда надо
              указать индекс элемента последовательности, по которому надо сортировать сами
              последовательности.
            </p>
            <p>
              Например, есть <code>t</code> — список кортежей, устроенных следующим образом: (имя, фамилия,
              средняя оценка, класс). Для сортировки таких кортежей по средней оценке достаточно указать
              функцию, возвращающую одно значение: 2-й элемент своего аргумента.
            </p>
          </li>
          <li>
            <p>
              параметр <code>reverse</code>: если он равен <code>True</code>, то результат сравнений элементов
              заменяется на обратный.
            </p>
            <p>
              Ниже приведены результаты сравнения разных способов вызова метода <code>t.sort()</code> для списков из
              <code>n</code> кортежей (список <code>t</code>) или целых чисел (список <code>q</code>). Стоит помнить о
              том, что использование параметра <code>key</code>
            </p>
            <pre class="python">n = 10
t = [randint(0, 9), randint(0, 9)) for i in range(n)]
q = [randint(0, 99) for i in range(n)]

print(t)
print q

def cmp_point(a, b):
    if a[0] &lt; b[0]:
        return -1
    if a[0] == b[0] and a[1] &lt; b[1]:
        return -1
    if a[1] == b[1]:
        return 0
    return 1

def cmp_sum(a):
    return sum(a)

def cmp_first(x):
    return x[1]

def cmp_digitsum(a):
    s = 0
    while a&gt;0:
        s += a % 10
        a = a // 10
    return s

t.sort(key = cmp_first)     # сортируем кортежи по элементу, имеющему индекс 1
print(t)
t.sort(key = cmp_sum)       # сортируем по сумме элементов кортежа
print(t)
q.sort(key = cmp_digitsum)  # сортируем по сумме цифр целого числа
print(q)
</pre>
            <p>Результаты вычислений:</p>
            <pre class="python">
# исходные данные
[(5, 0), (9, 7), (0, 3), (6, 1), (3, 5), (2, 0), (5, 4), (7, 0), (9, 7), (6, 1)]
[65, 99, 55, 30, 49, 67, 3, 92, 94, 49]

# результаты сортировок
[(5, 0), (2, 0), (7, 0), (6, 1), (6, 1), (0, 3), (5, 4), (3, 5), (9, 7), (9, 7)]
[(2, 0), (0, 3), (5, 0), (7, 0), (6, 1), (6, 1), (3, 5), (5, 4), (9, 7), (9, 7)]
[30, 3, 55, 65, 92, 49, 67, 94, 49, 99]
</pre>
          </li>
        </ul>
      </li>
    </ul>
    <h3>Методы работы со строками</h3>
    <ul>
      <li>
        <p>метод <code>str.capitalize()</code></p>
        <p>
          Метод возвращает копию строки <code>str</code>, первый символ которой набран в верхнем регистре,
          а все остальные — в нижнем. Символы, отличные от латинских букв, остаются без изменения.
        </p>
        <pre class="python">
print('family'.capitalize())           # Family
print('english GRAMMAR'.capitalize())  # English grammar
</pre>
      </li>
      <li>
        <p>метод <code>str.center(width[, fillchar])</code></p>
        <p>
          Метод возвращает строку <code>str</code>, дополненную символами <code>fillchar</code> до ширины,
          равной <code>width</code>, а строку <code>str</code> помещает посередине.
        </p>
        <pre class="python">
print('abc'.center(4))       # 'abc '
print('abc'.center(2))       # 'abc'
print('abc'.center(11,'_'))  # '____abc____'
</pre>
      </li>
      <li>
        <p>метод <code>str.count(sub[, start[, end]])</code></p>
        <p>
          Метод возвращает количество неперекрывающихся подстрок <code>sub</code> в сечении строки <code>str[start:end]</code>.
        </p>
        <pre class="python">
print('abababaca'.count('aba'))        # 2
print('ababababa'.count('ababa'))      # 1
print('eeeeeeeee'.count('ee', 3, 7))   # 2
</pre>
      </li>
      <li>
        <p>метод <code>str.endswith(suffix[, start[, end]])</code></p>
        <p>
          Метод возвращает значение <code>True</code>, если строка <code>str</code> заканчивается на
          строку <code>suffix</code> (говорят, что строка <code>suffix</code> является суффиксом строки
          <code>str</code>) и <code>False</code> в противном случае.
        </p>
        <p>
          Если указаны параметры <code>start</code> и/или <code>end</code>, то суффикс ищется в срезе
          <code>str[start:end]</code>.
        </p>
        <p>
          Если не указан <code>start</code>, то суффикс ищется с начала строки, если не указан
          <code>end</code>, то суффикс ищется до конца строки. Если указан только один дополнительный
          параметр, то считается, что это параметр <code>start</code>.
        </p>
        <pre class="python">
print('abababaca'.endswith('aba'))           # False
print('abababaca'.endswith('babaca', 3, 9))  # True
print('aaaabbbb'.endswith('ab', 3))          # False
print('cddccddc'.endswith('ccdd', 0, 7))     # True
</pre>
      </li>
      <li>
        <p>метод <code>str.find(sub[, start[, end]])</code></p>
        <p>
          Метод возвращает наименьший индекс, с которого подстрока <code>sub</code> входит в строку <code>str</code>.
        </p>
        <p>
          Если указаны дополнительные параметры <code>start</code> и <code>end</code>, то поиск
          осуществляется в срезе <code>str[start:end]</code>. При этом возвращаемый индекс расчитывается
          относительно самой строки, а не её среза.
        </p>
        <p>
          Если строка не найдена, возвращается -1.
        </p>
        <pre class="python">
print('this is the end'.find('is '))   # 2
print('this is the end'.find(' is '))  # 4
print('this is the end'.find('  '))    # -1
print('abababaca'.find('bac', 3, 8))   #5
</pre>
      </li>
      <li>
        <p>метод <code>str.index(sub[, start[, end]])</code></p>
        <p>
          Метод аналогичен <code>find</code> за тем исключением, что если строка <code>sub</code> не
          найдена, генерируется исключение <code>ValueError</code> (об исключениях в этой книге ничего не
          написано, почитайте самостоятельно).
        </p>
      </li>
      <li>
        <p>метод <code>str.isalnum()</code></p>
        <p>
          Возвращает <code>True</code>, если все символы непустой строки — это буквы или цифры, <code>False</code>
          в противном случае.
        </p>
      </li>
      <li>
        <p>
          <p>метод <code>str.isalpha()</code></p>
        </p>
        <p>
          Возвращает <code>True</code>, если все символы непустой строки — это буквы, <code>False</code> в
          противном случае.
        </p>
      </li>
      <li>
        <p>метод <code>str.isdigit()</code></p>
        <p>
          Возвращает <code>True</code>, если все символы непустой строки — это цифры, <code>False</code> в
          противном случае.
        </p>
      </li>
      <li>
        <p>метод <code>str.islower()</code></p>
        <p>
          Возвращает <code>True</code>, если все буквы строки — это строчные буквы, <code>False</code> в
          противном случае.
        </p>
      </li>
      <li>
        <p>метод <code>str.isspace()</code></p>
        <p>
          Возвращает <code>True</code>, если все символы непустой строки — это пробелы, <code>False</code>
          в противном случае.
        </p>
      </li>
      <li>
        <p>метод <code>str.isupper()</code></p>
        <p>
          Возвращает <code>True</code>, если все буквы строки — это прописные буквы, <code>False</code> в
          противном случае.
        </p>
      </li>
      <li>
        <p>метод <code>str.join(iterable)</code></p>
        <p>
          Очень важный и полезный метод!
        </p>
        <p>
          Возвращает строку, которая получена конкатенацией элементов последовательности
          (<code>iterable</code>), переданной в качестве параметра. Элементы последовательности должны
          быть строками. Разделитель элементов в данном случае — строка, ''от лица'' которой был вызван
          метод. Под строкой с вызовом метода <code>join</code> указан результат вывода.
        </p>
        <pre class="python">
print('.'.join('abcde'))
a.b.c.d.e

print(' '.join(['it','explains','a','lot']))
it explains a lot

# если элементы последовательности - не строки, то их следует привести к этому типу
x = [1, 3, 24, 5, 6, 7]
print(' '.join(str(elem) for elem in x))
1 3 24 5 6 7

# или так:
print(' '.join(map(str, x)))

print(', '.join(str(a) for a in (234, 2.3e-3, 'twenty two')))
234, 0.0023, twenty two
</pre>
      </li>
      <li>
        <p>метод <code>str.ljust(width[, fillchar])</code></p>
        <p>
          То же, что и <code>str.center(width[, fillchar])</code>, но располагает строку <code>str</code>
          не по центру, а ''прижимает'' её к левому краю.
        </p>
      </li>
      <li>
        <p>метод <code>str.lower()</code></p>
        <p>
          Возвращает строку <code>str</code>, все буквы которой переведены в нижний регистр.
        </p>
        <pre class="python">
print('abCDeFGh'.lower())   # abcdefgh
print('123.45'.lower())     # 123.45
print('3E23'.lower())       # 3e23
</pre>
      </li>
      <li>
        <p>метод <code>str.lstrip([chars])</code></p>
        <p>
          Возвращает строку, полученную из <code>str</code> следующим образом: из начала строки
          <code>str</code> удаляются <b>все</b> символы, перечисленные в строке <code>chars</code>. Если
          параметр <code>chars</code> не указан, то по умолчанию удаляются пробелы.
        </p>
        <pre class="python">
print('   spacious   '.lstrip())           # 'spacious   '
print('www.example.com'.lstrip('cmowz.'))  # 'example.com'
</pre>
        <p>
          Надо понимать, что в <code>chars</code> указывается не префикс, который надо удалить, а именно
          набор символов. После преобразования <em>первый</em> символ получившейся строки гарантированно
          остутствует в строке <code>chars</code>.
        </p>
      </li>
      <li>
        <p>метод <code>str.partition(sep)</code></p>
        <p>
          Сначала находится место первого вхождения строки <code>sep</code> в строку <code>str</code>.
          Метод возвращает кортеж, состоящий из трёх строк: часть до разделителя <code>sep</code>, сам
          разделитель, и часть после разделителя.
        </p>
        <p>
          Если строка <code>sep</code> не найдена, то первый элемент кортежа это исходная строка,
          остальные два — пустые строки.
        </p>
        <pre class="python">
print('word#text string'.partition('#')  # ('word', '#', 'text string'))
</pre>
      </li>
      <li>
        <p>метод <code>str.replace(old, new[, count])</code></p>
        <p>
          Возвращает копию строки <code>str</code>, в которой все вхождения <code>old</code> заменены на
          <code>new</code>. Если указан параметр <code>count</code>, то заменяются только первые <code>count</code>
          вхождений.
        </p>
        <pre class="python">
print('13 43 56'.replace(' ', ':'))          # '13:43:56'
print('ddouble dd'.replace('dd', 'd'))       # 'double d'
print('abcabcabc'.replace('bca', 'abc', 1))  # 'aabcbcabc'
</pre>
      </li>
      <li>
        <p>метод <code>str.rjust(width[, fillchar])</code></p>
        <p>
          То же, что и <code>str.center(width[, fillchar])</code>, но располагает строку <code>str</code>
          не по центру, а ''прижимает'' её к правому краю.
        </p>
        <pre class="python">x = [1, 2, 3, 4]
for a in x:
  print(str(a).rjust(4, ' '), end = '')
</pre>
      </li>
      <li>
        <p>метод <code>str.split([sep[, maxsplit]])</code></p>
        <p>
          <b>Очень важный и полезный метод!</b>
        </p>
        <p>
          Разбивает строку <code>str</code> на подстроки, используя <code>sep</code> как разделитель и
          возвращает их список.
        </p>
        <p>
          Если параметр <code>sep</code> не указан, то считается, что он равен пробелу. Если указан
          параметр <code>maxsplit</code>, то делается не более <code>maxsplit</code> разбиений (т.е.
          список содержит <code>maxsplit + 1</code> строку). Параметр <code>sep</code> может содержать
          больше одного символа.
        </p>
        <p>
          Метод по-разному интерпретирует разделитель в зависимости от того — указан ли он явно при вызове
          или используется значение по умолчанию (пробел):
        </p>
        <ul class="nestedUl">
          <li>
            если параметр <code>sep</code> не указан или указано значение <code>None</code>, то группы
            подряд идущих пробелов интерпретируются, как один разделитель;
          </li>
          <li>
            если же параметр <code>sep</code> указан явно, то каждый из идущих подряд разделителей
            интерпретируется, как самостоятельный разделитель и в таком случае в списке появляются
            пустые строки.
          </li>
        </ul>
        <pre class="python">
print('192.168.0.100'.split('.'))     # ['192', '168', '0', '100']
print(' 1  2   3  '.split())          # ['1', '2', '3']
print(' 1  2   3  '.split(' '))       # ['', '1', '', '2', '', '', '3', '', '']
print('  1  2   3  '.split(None, 1))  # ['1', '2   3  ']
print('1&lt;&gt;2&lt;&gt;3'.split('&lt;&gt;'))          # ['1', '2', '3']
print('1,,2'.split(','))              # ['1', '', '2']
</pre>
        Кроме прочего, метод <code>split</code> используется в стандартной операции чтения массива целых
        чисел, записанных в одной строке через пробел.
        <pre class="python">
x = list(map(int, input().split()))   # если была введена строка '1 23 34 -43'
print(x)          # программа выведет [1, 23, 34, -43]
</pre>
      </li>
      <li>
        <p>метод <code>str.startswith(prefix[, start[, end]])</code></p>
        <p>
          Метод возвращает значение <code>True</code>, если строка <code>str</code> начинается на строку
          <code>prefix</code> (говорят, что строка <code>prefix</code> является префиксом строки
          <code>str</code>) и <code>False</code> в противном случае.
        </p>
        <p>
          Если указаны параметры <code>start</code> и/или <code>end</code>, то префикс ищется в срезе
          <code>str[start:end]</code>.
        </p>
        <p>
          Если не указан <code>start</code>, то префикс ищется с начала строки, если не указан
          <code>end</code>, то префикс ищется до конца строки. Если указан только один дополнительный
          параметр, то считается, что это параметр <code>start</code>.
        </p>
        <pre class="python">
print('abababaca'.startswith('aba'))           # True
print('abababaca'.startswith('babac', 1, 7))   # False
print('aaaabbbb'.startswith('ab', 3))          # True
print('cddccddc'.startswith('ccdd', 0, 7))     # False
</pre>
      </li>
      <li>
        <p>метод <code>str.strip([chars])</code></p>
        <p>
          Метод возвращает строку, последовательно обработанную методами <code>lstrip</code> и <code>rstrip</code>.
        </p>
      </li>
      <li>
        <p>метод <code>str.upper()</code></p>
        <p>
          Возвращает строку <code>str</code>, все буквы которой переведены в верхний регистр.
        </p>
        <pre class="python">
print('abCDeFGh'.upper())   # ABCDEFGH
print('123.45'.upper())     # 123.45
print('28mb'.upper())       # 28MB
</pre>
      </li>
    </ul>
    <h1>Работа с файлами</h1>
    <p>
      До сих пор наши программы ничего не сохраняли в результате своей работы. Как правило они работали
      недолго, входные данные либо создавались самой программой, либо запрашивались у пользователя. Результат
      работы выводился на экран и следующий запуск программы начинался с чистого листа.
      Другие программы могут работать продолжительное время (или постоянно, как операционная система или
      веб-сервер), могут сохранять результат работы таким образом, чтобы его можно было его использовать после
      перезапуска программы.
    </p>
    <h2>Режимы работы с файлами</h2>
    <p>
      В этой главе понятие текстового файла, пути файла считается известным или по крайней мере интуитивно
      понятным.
    </p>
    <p>
      Для работы с файлом нужно его <em>открыть</em>. Эту операцию выполняет функция <code>open(filename,
        mode)</code>. Первый параметр (строка) определяет имя открываемого для работы файла и может содержать
      имя файла (тогда он ищется в текущем каталоге) или его абсолютное имя (вместе с путём, где этот файл
      находится).
      Параметр <code>mode</code> определяет способ работы с открываемым файлом:
    </p>
    <ul>
      <li><em>чтение</em> (<code>mode='r'</code>): файл только читается, изменять его нельзя
      </li>
      <li><em>добавление</em> (<code>mode='a'</code>): собираемся дописывать информацию в его конец
      </li>
      <li><em>запись</em> (<code>mode='w'</code>): создаём для записи новый файл
      </li>
    </ul>
    <p>
      Если существующий файл открывается с параметром <code>'w'</code>, то его содержимое удаляется.
    </p>
    <p>
      Если параметр <code>mode</code> не указан, то считается, что он равен <code>'r'</code>.
      <br>
    </p>
    <p>
      Примеры использования:
    </p>
    <pre class="python">
open('text.txt', 'r')                  # файл text.txt из текущего каталога
                                       # открывается на чтение
open('d:\\python\\data\\a.dat', 'w')      # файл a.dat из каталога d:\\python\\data
                                       # открывается для записи
open('\\usr\\name\\file.in', 'a')         # файл file.in из каталога \\usr\\name
                                       # открывается на запись в его конец
</pre>
    <h2>Чтение из файла</h2>
    <p>
      Как было отмечено в предыдущем разделе, работы с файлом начинается с его открытия в одном из трёх
      режимов. Функция <code>open</code> возвращает объект, обращаясь к которому мы и будем выполнять все
      необходимые манипуляции с файлом. После работы с файлом его необходимо закрыть. В языке Python можно
      оформить открытие файла в виде отдельного блока, по окончании выполнения которого файл автоматически
      закроется:
    </p>
    <pre class="python">
with open('test.txt') as f:
    ...
    ...
</pre>
    <p>
      Строчка, начинающаяся со служебного слова <code>with</code> является заголовком блока, все операторы
      которого должны быть записаны ниже со стандартным отступом (как блоки, соответствующие условному
      оператору или оператору цикла). По окончании блока файл автоматически закроется.
    </p>
    <p>
      Для иллюстрации методов работы с файлом был создан файл <code>alice.txt</code> с таким текстом:
    </p>
    <pre class="python">
The rabbit-hole went straight on like a tunnel
for some way, and then dipped suddenly down,
so suddenly that Alice had not a moment to think
about stopping herself before she found herself
falling down a very deep well.
</pre>
    Для чтения файла в Python используются следующие методы (каждый вызывается для объекта файла, упомянутого
    выше):
    <ul>
      <li>
        <code>f.read(n)</code>
        <p>
          Параметр <code>n</code> — целое число. Если он указан, то метод возвращает строку, состоящую из
          следующих <code>n</code> символов файла. Если параметр не указан, то в строку считывается весь
          файл целиком, начиная с текущей позиции, т.е. с того символа, до которого файл был прочитан к
          настоящему моменту.
        </p>
        <pre class="python">with open('alice.txt') as f:
    print(f.read(10))      # 'The rabbit'
    print(f.read(10))      # '-hole went'
    print(f.read())        # все оставшиеся символы файла
</pre>
      </li>
      <li>
        <code>f.readline()</code>
        <p>
          Метод читает одну строку (до символа переноса строки \texttt'\symbol92n'). Возвращается
          прочитанная строка, включая символ переноса строки. Например, ниже показано, как вывести на
          печать файл с нумерацией его строк:
        </p>
        <pre class="python">i = 1
with open('alice.txt') as f:
    s = f.readline()
    while s != '':
        print('{0:d} {1:s}'.format(i, s), end = '')
        i += 1
        s = f.readline()
</pre>
        <p>
          Другой пример — чтение из файла <code>input.txt</code> двумерной таблицы целых чисел:
        </p>
        <pre class="python">x = []
with open('input.txt') as f:
    s = f.readline()
    while s != '':
        x.append([int(z) for z in s.split()])
        s = f.readline()

for i in range(len(x)):
    print(' '.join(str(elem) for elem in x[i]))
</pre>
      </li>
      <li>
        <code>f.readlines()</code>
        <p>
          Метод читает весь файл построчно, возвращает список строк (включая символы переноса строки).
        </p>
      </li>
      <li>
        <p>
          Помимо указанных методов работы с файлами в языке Python существует следующая удобная конструкция,
          позволяющая перебирать строки файла, аналогичная циклу <code>for</code> без параметра. Тогда пример
          с печатью нумерованных строк файла можно записать короче и естественней:
        </p>
        <pre class="python">i = 1
with open('alice.txt') as f:
    for line in f:
        print('{0:d} {1:s}'.format(i, line), end = '')
        i += 1
</pre>
      </li>
    </ul>
    <h2>Запись в файл</h2>
    <p>
      Для записи в файл надо открыть файл для записи (режим <code>w</code>) или дописывания (режим
      <code>a</code>).
    </p>
    <p>
      Рассмотрим пример:
    </p>
    <pre class="python"># создаём в текущем каталоге файл с именем output.txt
# если такой файл уже был, его содержимое стирается
with open('output.txt', 'w') as f:
    # метод write записывает в файл, ассоцированный с переменной f, заданную строку
    f.write('Lewis Carroll')

# открываем файл output.txt для дозаписывания
# если такого файла не было, он создаётся
with open('output.txt', 'a') as f:
    # первый символ записываемой строки: переход на следующую строку в файле
    f.write("\\nAlice's Adventures in Wonderland")
</pre>
    <h1>Динамическая типизация. Переменные, объекты, ссылки.</h1>
    <p>
      Мы все время использовали переменные, не объявляя предварительно ни их самих, ни их типы, и все как-то
      работало. Например, когда выполняется инструкция <code>а=3</code>, как интерпретатор Python узнает, что
      речь идет о целом числе?
      Тип переменной в языке Python определяется автоматически во время выполнения программы, а не в
      результате объявления в программном коде. Поэтому одна и та же переменная в ходе работы программы может
    </p>
    <h2>Переменные, объекты и ссылки</h2>
    <p>
      Прежде чем мы выясним, как обрабатывается оператор присваивания вроде <code>a = 3</code>, разберёмся,
      как интерпретатор вообще узнаёт о существовании переменных в программе.
    </p>
    <ul>
      <li>
        <em>Создание переменной</em>
        <p>
          Переменная (то есть имя) создается автоматически, когда в программе ей впервые присваивается значение.
          Все последующие операции присваивания просто изменяют значение, ассоциированное с уже созданным именем.
        </p>
      </li>
      <li>
        <em>Типы переменных</em>
        <p>
          Переменные не имеют никакой информации о типе или ограничениях, связанных с ним. Понятие типа присуще
          объектам, а не именам. Переменные универсальны по своей природе — они всегда являются всего лишь
          ссылками на конкретные объекты в конкретные моменты времени.
        </p>
      </li>
      <li>
        <em>Использование переменной</em>
        <p>
          Когда переменная участвует в выражении, ее имя замещается объектом, на который она в настоящий момент
          ссылается, после чего выражение вычисляется. Кроме того, прежде чем переменную можно будет использовать,
          ей должно быть присвоено значение — использование неинициализированной переменной приведет к ошибке.
        </p>
      </li>
    </ul>
    <p>
      Итак:
      <br>
      <em>Переменная</em> это ссылка на место в памяти, где хранится объект; переменная создаётся при
      выполнении первой операции присваивания ей значения; переменная может ссылаться на объект любого типа и
      ей должно быть присвоено некоторое значение, прежде чем её можно будет использовать.
    </p>
    <p>
      Это означает, что от вас не требуется заранее объявлять переменные в программе, но вы должны
      инициализировать их перед использованием — счетчик, например, должен быть инициализирован нулевым
      значением, прежде чем его можно будет увеличивать.
    </p>
    <p>
      <em>Объект</em> это область памяти, где помимо значения объекта хранится также информация о типе этого
      значения и счётчик ссылок на это значение.
      Таким образом, при выполнении оператора присваивания <code>a = 3</code>:
    </p>
    <ul>
      <li>
        Создается объект (выделяется память, записывается значение), представляющий число 3.
      </li>
      <li>
        Создается переменная <code>а</code>, если она еще отсутствует.
      </li>
      <li>
        В переменную <code>а</code> записывается ссылка на вновь созданный объект, представляющий число 3.
      </li>
    </ul>
    <h2>Автоматическая сборка мусора</h2>
    <p>
      До сих пор говорилось об особенностях создания и хранения объектов в памяти. А бывают ли ситуации, когда
      объекты освобождают занимаемую память? Рассмотрим такую последовательность операторов:
    </p>
    <br>
    <pre class="python">
a = 4
a = 'aaa'
a = 5.9
</pre>
    <p>
      Имя <code>a</code> последовательно указывает на объект типа целое число, потом на строку и в конце концов на
      вещественное число. Но что происходит с прежним значением после того, как выполняется новое присваивание?
    </p>
    <p>
      Всякий раз, когда имя ассоциируется с новым объектом, интерпретатор Python освобождает память,
      занимаемую предыдущим объектом (если на него не ссылается какое-либо другое имя). Такое автоматическое
      освобождение памяти, занимаемой объектами, называется сборкой мусора (<em>garbage collection</em>).
    </p>
    <p>
      В каждом объекте имеется счетчик ссылок, с помощью которого интерпретатор следит за количеством ссылок,
      указывающих на объект в настоящий момент времени. Как только значение счетчика достигает нуля (и только
      в этот момент), память, занимаемая объектом, автоматически освобождается. В предыдущем примере мы
      исходили из предположения, что всякий раз, когда имя <code>a</code> ассоциируется с новым объектом,
      счетчик предыдущего объекта уменьшается до нуля, заставляя интерпретатор освобождать память.
    </p>
    <p>
      Важно понимать, что в указанном коде <em>не происходит</em> создание новой переменной <code>a</code>. В
      памяти создаются <em>новые объекты</em> (строка <code>'aaa'</code>, вещественное число <code>5.9</code>),
      а переменная <code>a</code> всякий раз получает в качестве значения ссылку на новый объект. Прежний
      объект при этом освобождает память.
    </p>
    <p>
      Ещё пример:
    </p>
    <pre class="python">
a = 4  # создан объект - целое число 4, на него указывает имя a
b = 4  # в памяти уже существует объект целого типа со значением 4
       # поэтому имя b указывает на него
       # у объекта с целым значением 4 счётчик ссылок теперь равен 2
a = 10 # создаётся объект - целое число со значением 10 (счётчик ссылок равен 1)
       # счётчик ссылок у числа 4 становится равным 1
b = 10 # счётчик ссылок на целое число 10 теперь равен 2 (на него указывают a и b)
       # на 4 не указывает ни одно имя, объект освобождает память
</pre>
    <h2>Разделяемые ссылки, изменяемые и неизменяемые типы</h2>
    <p>Рассмотрим другой пример:</p>
    <pre class="python">
a = 5
b = a
print(a is b)  # True
print(a, b)    # 5 5
</pre>
    <p>
      Оператор <code>is</code>, упоминавшийся в Главе 1, отвечает на вопрос — являются ли два объекта идентичными
      (т.е. занимают одно и то же место в памяти). Идентичные объекты обязательно равны, обратное неверно.
      После присваивания <code>b = a</code> интерпретатор создаёт переменную <code>b</code> и использует для
      инициализации переменную <code>а</code>, при этом она замещается объектом, на который ссылается
      (<code>5</code>), и <code>b</code>
      превращается в ссылку на этот объект. В результате переменные <code>а</code> и <code>b</code> ссылаются на
      один и тот же объект (то есть указывают на одну и ту же область в памяти). В языке Python это называется
      разделяемая ссылка.
      Однако, такие механизмы создания объектов и сопоставления переменных и объектов не являются универсальными.
      Рассмотрим следующие примеры:
    </p>
    <br>
    <table class="normtbl codeTable long">
      <tbody>
        <tr>
          <td>
            <pre class="python">
a = 5
b = 5
print(a is b)
print(a, b)
</pre>
          </td>
          <td>
            <pre class="python">
a = 5
b = a
print(a is b)
print(a, b)
</pre>
          </td>
          <td>
            <pre class="python">
a = 'abcde'
b = 'abcde'
print(a is b)
print(a, b)
</pre>
          </td>
        </tr>

        <tr>
          <td>
            <pre class="python">
True
5 5
</pre>
          </td>
          <td>
            <pre class="python">
True
5 5
</pre>
          </td>
          <td>
            <pre class="python">
True
abcde abcde
</pre>
          </td>
        </tr>

        <tr>
          <td>
            <pre class="python">
a = 'abcde'
b = a
print(a is b)
print(a, b)
</pre>
          </td>
          <td>
            <pre class="python">
a = [5, 6]
b = [5, 6]
print(a == b)
print(a is b)
a[0] = 9
print(a, b)
</pre>
          </td>
          <td>
            <pre class="python">
a = [5, 6]
b = a
print(a == b)
print(a is b)
a[0] = 9
print(a, b)
</pre>
          </td>
        </tr>

        <tr>
          <td>
            <pre class="python">
True
abcde abcde
</pre>
          </td>
          <td>
            <pre class="python">
True
False
[9, 6] [5, 6]
</pre>
          </td>
          <td>
            <pre class="python">
True
True
[9, 6] [9, 6]
</pre>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <p>
      Видно, что целый тип и строки ведут себя так, как описывалось в первом примере. Если объект с таким
      значением уже существует, то его копия не создаётся, а переменной присваивается ссылка на уже
      существующее значение <code>5</code> или <code>'abcde'</code>.
    </p>
    <p>
      Такие типы называются неизменяемыми (immutable). Неизменяемыми типами в языке Python являются числа,
      строки (<code>str</code>) и кортежи (<code>tuple</code>).
    </p>
    <p>
      Со списками всё выглядит иначе. Последовательность присваиваний
    </p>
    <pre class="python">
a = [5, 6]
b = [5, 6]
</pre>
    <p>
      очевидно гарантирует нам, что значение выражения <code>a==b</code> равно <code>True</code>. Но если
      попытаться выяснить — один и тот же это список (<code>a is b</code>), то оказывается, что это не так. Это
      можно проверить, изменив один из них (<code>a[0] = 9</code>).
    </p>
    <p>
      Семантика же оператора присваивания <code>b = a</code> не меняется. После выполнения присваивания
      переменная <code>b</code> указывает на тот же объект, что и <code>a</code>. Так что все изменения списка
      <code>a</code> — это и изменения списка <code>b</code> — это один и тот же объект.
      Такие типы называются изменяемыми (mutable). В языке Python изменямыми типами являются списки (<code>list</code>)
      и словари (<code>dict</code>).
      <br>
    </p>
    <p>
      Проверьте вашу интуицию. Что выдаст проверка в таком случае?
    </p>
    <pre class="python">
a = [5, 6]
b = a + []
print(a == b, a is b)
</pre>
    Вопрос: как же скопировать список, если нам нужна ''независимая'' копия? Если список не вложенный, то можно
    применить три способа:
    <ul>
      <li>
        <p>сечения:</p>
        <pre class="python">
a = [5, 6]
b = a[:]
</pre>
      </li>
      <li>
        <p>функция <code>list()</code>:</p>
        <pre class="python">
a = [5, 6]
b = list(a)
</pre>
      </li>
      <li>
        <p>функция <code>copy</code> из одноимённого модуля</p>
        <pre class="python">
from copy import copy
a = [5, 6]
b = copy(a)
</pre>
      </li>
    </ul>
    <p>
      Если список вложенный, то ни один из указанных выше методов не даст желаемого результата. Проверьте интуицию
      снова: что выведет программа в каждом из фрагментов?
    </p>
    <ul>
      <li>
        <pre class="python">
from copy import copy
a = [[1, 2], [3, 4]]
b = copy(a)
a[0] = [8, 9]
print(a, b)
</pre>
      </li>
      <li>
        <pre class="python">
from copy import copy
a = [[1, 2], [3, 4]]
b = copy(a)
a[0][0] = 99
print(a, b)
</pre>
      </li>
    </ul>
    <p>Правильно копировать вложенные списки (и словари) надо так:</p>
    <pre class="python">
from copy import deepcopy
a = [[1, 2], [3, 4]]
b = deepcopy(a)

# вложенные словари:
a = 'x':[1, 2], 'y': [3, 4]
b = deepcopy(a)
</pre>
    <p>Ещё один пример с вложенными списками:</p>
    <pre class="python">
t = [1,2]
x = []
x = [t, t[:]]
print(x)       # [[1, 2], [1, 2]]
t[0] = 99      # изменяем список t, но первый элемент списка x это тот же самый объект!
               # поэтому ничего удивительного в следующем результате:
print(x)       # [[99, 2], [1, 2]]
</pre>
    <h1>Функции, параметры, вызовы функций</h1>
    <p>
      Используя известные к этому времени конструкции (присваивание, ввод/вывод, условный оператор и оператор
      цикла) можно запрограммировать любой алгоритм. Так и происходит с несложными задачами и небольшими
      программами. Но с ростом сложности задач оставаться в этих рамках становится всё труднее.
    </p>
    <p>
      Наряду с основными конструкциями в большинстве языков существуют способы, реализующие идеи <em>декомпозиции</em>
      и <em>абстракции</em>.
    </p>
    <p>
      <em>Декомпозиция</em> — способ разбиения текста программы на отдельные блоки, каждый из которых
      реализует определённую осмысленную задачу, часть общей работы. Одни и те же блоки могут быть
      использованы в разных местах программы (или нескольких программ).
    </p>
    <p>
      <em>Абстракция</em> — позволяет сконцентрироваться на смысле и сути данных и/или программы, не обращая
      внимания на особенности реализации этих данных и/или программы.
    </p>
    <p>
      В языке Python, как и в большинстве других языков, для реализации идей декомпозиции и абстракции
      используются, в частности, функции. Функции можно рассматривать как способ задавать новые, более сложные
      "&lt;примитивы"&gt; (команды) языка.
    </p>
    <h2>Определение функции</h2>
    <p>
      Синтаксис определения функции:
    </p>
    <pre class="python">
def &lt;имя функции&gt;(&lt;список формальных параметров&gt;):
    &lt;составной оператор&gt;
</pre>
    <p>
      где <code>&lt;имя функции&gt;</code> — идентификатор, <code>&lt;список формальных параметров&gt;</code> —
      список идентификаторов, разделённых запятыми, <code>&lt;составной оператор&gt;</code> — один или несколько
      операторов, которые называются телом функции. По аналогии с условным оператором и оператором цикла тело
      функции записывается со стандартным отступом. Если список формальных параметров пуст, скобки всё равно
      ставятся.
      <br>
      Функции можно разделить на два класса:
    </p>
    <ul>
      <li>
        функции, возвращающие значение — в теле такой функции должен встретиться хотя бы один оператор
        <code>return</code>.
      </li>
      <li>
        функции, не возвращающие значения
      </li>
    </ul>
    <p>Примеры функций, возвращающих значение:</p>
    <pre class="python"># функция возвращает значение: f(x) = x!
def factorial(x):
    res = 1
    if x == 0 or x == 1:
        return res
    while x &gt; 1:
        res = res * x
        x -= 1
    return res
</pre>
    <pre class="python"># функция возвращает количество цифр в десятичной записи числа n
def n_length(n):
    length = 0
    while n &gt; 0:
        n //= 10
        length += 1
    return length
</pre>
    <p>Оператор <code>return</code> выполняет следующие действия:</p>
    <ul>
      <li>вычисляет выражение, стоящее справа от слова <code>return</code>
      </li>
      <li>прекращает выполнение тела функции
      </li>
      <li>
        возвращает значение вычисленного выражения в качестве результата работы функции
      </li>
    </ul>
    <p>
      Таким образом, функции, возвращающие значение, можно использовать в выражениях (в правой части оператора
      присваивания, условиях операторов (<code>if, while</code>), оператора <code>print</code>).
    </p>
    <p>
      Тип значения функции определяется типом возвращаемого выражения, стоящего после <code>return</code> в
      теле функции.
    </p>
    <h2>Вызов функции, значение <code>None</code></h2>
    <p>
      Вызов функции записывается так: <br><code>&lt;имя функции&gt;(&lt;фактические параметры&gt;)</code><br>
      где <code>&lt;имя функции&gt;</code> — имя одной из определённых выше функций, <code>&lt;фактические
        параметры&gt;</code> — список выражений, разделённых запятыми.
      Перед выполнением функции значения этих выражений будут вычислены. С этими вычисленными значениями будут
      связаны имена соответствующих формальных параметров в описании функции. Таким образом, количество формальных
      и фактических параметров должно совпадать.
      Примеры вызовов функций, возвращающих значение:
    </p>
    <pre class="python"># функция возвращает значение: f(x) = x!
def factorial(x):
    res = 1
    if x == 0 or x == 1:
        return res
    while x &gt; 1:
        res = res * x
        x -= 1
    return res

n = int(input('Enter n:'))
k = int(input('Enter k:'))
# вычисление биномиальных коэффициентов
print(factorial(n) // (factorial(k) * factorial(n - k)))

# сокращение дроби
def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

a = int(input())
b = int(input())
g = gcd(a, b)
print('{0:d}/{1:d} = {2:d}/{3:d}'.format(a, b,  a // g, b // g))

# проверка, является ли число полным квадратом
def is_sqr(n):
    k = 0
    while k * k &lt; n:
        k += 1
    if k * k == n:
        return True
    return False

k = int(input('Enter k:'))
if is_sqr(k):
    print('YES')
else:
    print('NO')
</pre>
    <p>Пример вызова функции, не возвращающей значение:</p>
    <pre class="python"># Пример вызова функции, не возвращающей значение:
def step(k):
    i = 1
    while i &lt;= k:
        print('*', end = '')
        i += 1

def stairway(n):
    k = 1
    while k &lt;= n:
        step(k)
        k += 1
        print()

n = int(input('Enter stairway size:'))
stairway(n)
</pre>
    <p>
      Что произойдёт, если попытаться вычислить функцию, не возвращающую значение? Например, поместив её вызов в
      правую часть оператора присваивания или попытаться напечатать результат её выполнения? В этом случае функция
      возвращает значение <code>None</code>. Это специфическое значение — единственный представитель одноимённого
      типа <code>None</code>. <code>None</code>, приведённое к логическому типу, равно <code>False</code>.
    </p>
    <table class="normtbl codeTable">
      <tbody>
        <tr>
          <td>
            <pre class="python">def smart_print(t):
    for i in range(len(t)):
        print('x[%d] = %d'.format(i, t[i]))

t = [1, 2, 3]
smart_print(t)
</pre>
          </td>
          <td>
            <pre class="python">def smart_print(t):
    for i in range(len(t)):
        print 'x[%d] = %d'%(i, t[i])

t = [1, 2, 3]
print(smart_print(t))
</pre>
          </td>
        </tr>
        <tr>
          <td>
            <pre class="python">
x[0] = 1
x[1] = 2
x[2] = 3
</pre>
          </td>
          <td>
            <pre class="python">
x[0] = 1
x[1] = 2
x[2] = 3
None
</pre>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <p>
      Кому-то может показаться, что печать лишнего слова <code>None</code> не является большой проблемой,
      хотя, например, в автоматических проверяющих системах вывод должен точно соответствовать спецификации.
      Приведём теперь простой, но не такой безобидный пример.
    </p>
    <pre class="python">def odd(t):
    if t%2 == 0:
        return False

if odd(int(input())):
    print('odd')   # ничего не печатает, т.к. функция вернула None (т.е. False)
else:
    print('even')  # всегда печатаем even
</pre>
    <p>
      Функция <code>odd</code> по предположению автора должна возвращать значение <code>True</code>, если
      параметр нечётное число и <code>False</code> — в противном случае. Видно, что ничего кроме
      <code>False</code> она возвращать не умеет.
    </p>
    <p>
      Хуже того, при нечётном параметре она вообще ничего не возвращает. ''Ничего'' в данном случае означает
      значение <code>None</code>, которое при проверке в условном операторе вычисляется как <code>False</code>
      и программа печатает <code>even</code> (чётное).
    </p>
    <p>
      Такие семантические ошибки самые сложные. Дело в том, что на этапе выполнения программы интепретатором
      никаких ошибок нет, но иногда программа ведёт себя как положено, иногда — нет. Локализация таких ошибок
      может оказаться очень непростой задачей.
    </p>
    <h2>Запуск программы, содержащей функции</h2>
    <p>
      Файл, содержащий текст программы на языке Python выполняется последовательно сверху вниз — оператор за
      оператором. Определения функций, т.е. операторы, из которых они составлены, — не выполняются.
      Определение функции лишь описывает последовательность операторов, которую надо выполнить, если функция
      будет вызвана в тексте программы.
    </p>
    <p>
      Таким образом, оба приведённых ниже фрагмента выполняются одинаково: тело функции выполняется только в
      момент её, функции, вызова.
    </p>
    <table class="normtbl codeTable">
      <tbody>
        <tr>
          <td>
            <pre class="python">def factorial(x):
    res = 1
    if x == 0 or x == 1:
        return 1
    while x &gt; 1:
        res = res * x
        x -= 1
    return res

n = input('Enter n:')
print(factorial(n))
</pre>
          </td>
          <td>
            <pre class="python">def JustPrint():
    print('Hello!')

def factorial(x):
    res = 1
    if x == 0 or x == 1:
        return 1
    while x &gt; 1:
        res = res * x
        x -= 1
    return res

n = input('Enter n:')
print(factorial(n))
</pre>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <p>То же справедливо для любого количества функций, определённых в файле с программой на языке Python.</p>
    <h2>Блоки, области видимости имён, локальные и глобальные переменные</h2>
    <p>Блоком в Питоне называется последовательность операторов тела функции или всего файла.</p>
    <p>
      В примере, иллюстрирующем функции (см. <a href="#funcexample">funcexample</a>), возвращающие параметры,
      всего 4 блока: 3 блока — функции <code>factorial</code>, <code>n_length</code> и <code>is_sqr</code>,
      ещё один — включающий в себя первые три (они называются вложенными) и строки после описания функций.
    </p>
    <p>
      <b>Областью видимости имени считается блок, в которой это имя было связано с новым значением</b>, а
      также все вложенные в него блоки.
    </p>
    <p>
      Например:
    </p>
    <pre class="python">def f():
    return k + 1

k = 5
print(f())
</pre>
    <p>
      Здесь областью видимости переменной <code>k</code> является весь текст программы вместе с телом функции,
      т.к. она получила значение в блоке содержащем внутри себя тело функции (а внутри тела функции имя <code>k</code>
      не связывалось ни с каким значением). Таким образом, использование переменной <code>k</code> разрешено,
      программа выведет <code>6</code>. Такая переменная называется <em>глобальной</em>.
    </p>
    <p>
      Ещё пример:
    </p>
    <pre class="python">a = 20

def f(x):
    x = x + a
    return x

print(a, f(4))
</pre>
    <p>
      Будут выведены числа <code>20</code> и <code>24</code>. По умолчанию область видимости имени
      <code>a</code> распространяется на функции этого блока, в частности, на функцию <code>f</code>.
      Другой пример:
    </p>
    <pre class="python">a = 20

def f(x):
    a = 3
    x = x + a
    return x

print(a, f(4))
</pre>
    <p>
      Будут выведены числа <code>20</code> и <code>7</code>. Внутри функции <code>f(x)</code> имя
      <code>a</code> связано со значением 3. Область видимости этой переменной — функция <code>f</code>. Таким
      образом, имя <code>a</code> внутри функции существует отдельно от глобального имени <code>a</code>.
      Такая переменная называется <em>локальной</em>.
    </p>
    <p>
      Это же правило действует и для имён формальных параметров. Их имена являются <em>локальными</em>
      переменными:
    </p>
    <pre class="python">def f(a):
    return a * a

a = 20
print(a, f(4))
</pre>
    <p>Программа выведет числа <code>20</code> и <code>16</code>.</p>
    <p>
      А в следующем примере ошибка (<code>UnboundLocalError: local variable 'a' referenced before
        assignment</code>). Связано это с тем, что сам факт упоминания имени <code>a</code> в левой части
      оператора присваивания внутри функции (т.е. изменения значения переменной <code>a</code>) делает это имя
      локальным.
      <br>
      Значит при вычислении значения выражения <code>a = a + 3</code> потребуется значение <em>локальной</em>
      переменной <code>a</code>, которое пока неизвестно (имя <code>a</code> внутри функции не связано ни с
      каким значением к моменту вычисления выражения <code>a + 3</code>).
    </p>
    <pre class="python">a = 20

def f(x):
    a = a + 3
    x = x + a
    return x

print(a, f(4))
</pre>
    <p>И даже так нельзя:</p>
    <pre class="python">def f():
    print(a)
    if False:
        a = 0

a = 20
f()
</pre>
    <p>
      Несмотря на то, что оператор присваивания внутри функции <em>никогда</em> не будет выполнен, сам факт
      его присутствия внутри функции делает переменную <code>a</code> локальной, а значит при выполнении
      оператора <code>print</code> её значение будет неизвестно.
      Исправить ситуацию в первом примере можно так:
    </p>
    <pre class="python">a = 20

def f(x):
    b = a + 3
    x = x + b
    return x

print(a, f(4))
</pre>
    <p>Будут выведены числа 20 и 27.</p>
    <p>
      Подробнее об областях видимости и связывании читать в главе "&lt;Execution model"&gt; документации на
      английском языке: http://docs.python.org/reference/executionmodel.html
    </p>
    <p>
      В следующем параграфе будут более подробно рассмотрены способы передачи параметров в функции, и как с
      этим связано свойство изменяемости (mutablity).
    </p>
    <h2>Передача переменных изменяемых и неизменяемых типов в качестве параметров функций</h2>
    Знакомые с языком Паскаль или C + + знают, что существуют два принципиально разных способа передачи
    параметров функциям: передача параметра по значению и передача параметра по ссылке.
    <p>
      Первый означает, что в функцию передаётся копия и любые изменения этой копии внутри функции никак не
      отражаются на значении этого параметра снаружи функции.
    </p>
    <p>
      Второй означает, что в функцию передаётся ссылка на оригинал, поэтому изменение такого параметра внутри
      функции влечёт изменение оригинала.
    </p>
    <p>
      Представим себе, что параметр — \\TeX-версия этой книжки, на 23-й странице которой надо исправить
      опечатку и мы хотим поручить эту операцию корректору. Предположим, что оригинал этого файла находится в
      сети и доступен каждому желающему.
    </p>
    <p>
      Чтобы передать такой параметр по значению, можно скопировать файл и передать копию по электронной почте,
      распечатать книжку или только её 23-ю страницу. Тогда правка останется в копии (в копии файла, на листе
      бумаги), но никак не отразится на оригинальном файле. Для передачи параметра по ссылке надо сообщить
      адрес файла корректору, т.е. сообщить, где именно находится оригинал.
    </p>
    <p>
      В языке Python способ передачи параметра функции зависит от того, каков тип этого параметра: изменяемые
      типы передаются по ссылке, неизменяемые — по значению.
      В приведённых ниже примерах стандартная функция <code>id()</code> выводит идентификатор объекта. Можно
      считать, что это адрес, по которому хранится значение, с которым связана переменная, переданная в
      качестве параметра функции <code>id()</code>.
    </p>
    <ul>
      <li>
        <pre class="python">def ref_demo(x):
    print(x, id(x))   # локальная для функции переменная-параметр x
                      # связана со значением 10
                      # обе переменные (k и x)
                      # связаны с одним и тем же значением
    x = 42
    print(x, id(x))   # теперь x связана со значением 42
                       # k и x связаны с разными значениями

k = 10
print(k, id(k))  # переменная k связана со значением 10
ref_demo(k)
print(k, id(k))  # целочисленный тип является неизменяемым
                 # поэтому все изменения параметра внутри функции
                 # означали не изменение, а создание нового объекта
</pre>
        <p>Вывод, который мы видим после запуска программы:</p>
        <pre class="python">
k=10, id(k)=31041244
x=10, id(x)=31041244
x=42, id(x)=31040860
k=10, id(k)=31041244
</pre>
        <p>
          Конкретные значения функции <code>id()</code>, конечно, всякий раз будут другие, но главное — в
          третьей строчке <b>всегда</b> будет отличное от остальных число.
        </p>
      </li>
      <li>
        <p>
          Допустим, мы хотим описать функцию, осуществляющую параллельный перенос отрезка на заданный
          вектор.
        </p>
        <p>
          Отрезок задан координатами своих концов (элемент кортежа с индексом <em>0</em> — абсцисса, с индексом
          <em>1</em> — ордината).
        </p>
        <p>
          Вектор сдвига <em>\\overrightarrowOX</em> задан координатами точки <em>X</em> (точка <em>O</em> — начало
          координат).
        </p>
        <pre class="python"># Такое решение не будет работать просто потому, что кортежи нельзя изменять,
# в первой же строчке функции будет ошибка
def shift(a, b, x):
    a[0], b[0] = a[0]+x[0], b[0]+x[0]   # TypeError: 'tuple' object
                                        # does not support item assignment
    a[1], b[1] = a[1]+x[1], b[1]+x[1]

a = (1, 2)
b = (-3, 2)
shift(a, b, (1, 1))
print(a, b)

# В таком решении ошибок не будет, но цели мы не достигнем.
# Передаваемые параметры a и b - это кортежи, поэтому внутри функции shift
# они будут связаны с новыми значениями, которые "останутся" внутри функции
def shift(a, b, x):
    a = (a[0]+x[0], a[1]+x[1])   # создаём кортежи заново
    b = (b[0]+x[0], b[1]+x[1])
a = (1, 2)
b = (-3, 2)
shift(a, b, (1, 1))
print(a, b)          # (1, 2) (-3, 2)
</pre>
        <p>Решение задачи может выглядеть так:</p>
        <pre class="python">def shift(a, b, x):
    a = (a[0]+x[0], a[1]+x[1])
    b = (b[0]+x[0], b[1]+x[1])
    return a, b        # если нельзя изменить переданные параметры,
                       # вернём значения, вычисленные внутри функции

a = (1, 2)
b = (-3, 2)
a, b = shift(a, b, (1, 1))
print(a, b)             # (2, 3) (-2, 3)
</pre>
      </li>
    </ul>
    <p>Несколько примеров, иллюстрирующих передачу изменяемых объектов в качестве параметров функции:</p>
    <table class="normtbl codeTable long">
      <tbody>
        <tr>
          <td>
            <pre class="python">
def f1(t):
    print(t)
    t.append(57)
    print(t)

t = [1, 2, 3]
f1(t)
print(t)
</pre>
          </td>
          <td>
            <pre class="python">
[1, 2, 3]
[1, 2, 3, 57]
[1, 2, 3, 57]
</pre>
          </td>
        </tr>
        <tr>
          <td>
            <pre class="python">
        def f2(t):
            print(t)
            t[0] = 99
            print(t)

        t = [1, 2, 3]
        f2(t)
        print(t)
</pre>
          </td>
          <td>
            <pre class="python">
[1, 2, 3]
[99, 2, 3]
[99, 2, 3]
</pre>
          </td>
        </tr>
        <tr>
          <td>
            <pre class="python">
def f3(t):
    print(t)
    t = t + [34,45]
    print(t)

t = [1, 2, 3]
f3(t)
print(t)
</pre>
          </td>
          <td>
            <pre class="python">
[1, 2, 3]
[1, 2, 3, 34, 45]
[1, 2, 3]
</pre>
          </td>
        </tr>
        <tr>
          <td>
            <pre class="python">
def f4(t):
    print(t)
    t = t[:2] + [99] + t[3:]
    print(t)

t = [1, 2, 3, 4]
f4(t)
print(t)
</pre>
          </td>
          <td>
            <pre class="python">
[1, 2, 3, 4]
[1, 2, 99, 4]
[1, 2, 3, 4]
</pre>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <p>
      В каждой функции переменная-параметр <code>t</code> — локальная. В начале выполнения функции эта
      локальная переменная связывается со значением, которое имеет глобальная переменная <code>t</code>. Т.е.
      в начале работы функции на значение передаваемого списка "&lt;смотрят"&gt; две переменные — одна
      глобальная, вторая локальная.
    </p>
    <p>
      Затем в функциях <code>f1(t)</code> и <code>f2(t)</code> происходит изменение этого значения. В <code>f1(t)</code>
      в список добавляется число 57, в <code>f2(t)</code> нулевой элемент этого списка изменяется на 99.
    </p>
    <p>
      В функциях <code>f3(t)</code> и <code>f4(t)</code> создаётся <em>новое значение локальной
        переменной</em> <code>t</code>. Значение глобальной переменной <code>t</code> при этом не изменяется.
      Разберём ещё один пример:
    </p>
    <pre class="python">def f1(x):           # локальная переменная-параметр x связана
                     # со значением глобальной переменной t, равным [1, 2, 3, 4, 5, 6, 7]
    x = [44] + x[1:] # создано новое значение, равное [44, 2, 3, 4, 5, 6, 7]
                     # с этим значением связана локальная переменная x
    x[1] = 99        # новое значение, созданное внутри функции, изменяется
                     # теперь оно равно [44, 99, 3, 4, 5, 6, 7]

def f2(x):           # локальная переменная-параметр x связана
                     # со значением глобальной переменной t, равным [1, 2, 3, 4, 5, 6, 7]
    x[1] = 99        # изменяется значение, с которым связана локальная переменная x
                     # таким образом, изменяется значение,
                     # с которым связаны две переменных: локальная x и глобальная t
    x = [44] + x[1:] # создано новое значение, равное [44, 2, 3, 4, 5, 6, 7]
                     # с этим значением связана только локальная переменная x
                     # изменённый на предыдущем шаге список сохранил значение
    x[3] = 99        # изменяется новое значение, созданное на предыдущем шагу
                     # значение, связанное с глобальной переменной t

t = [1, 2, 3, 4, 5, 6, 7]
f1(t)
print(t)             # [1, 2, 3, 4, 5, 6, 7]
t = [1, 2, 3, 4, 5, 6, 7]
f2(t)
print(t)             # [1, 99, 3, 4, 5, 6, 7]
</pre>
    <p>
      Важно понимать, что случаи 1 и 2 возможны лишь при передаче в качестве параметров значений изменяемых типов
      (таких как список). Метод <code>append</code> и изменение элемента списка с заданным индексом — суть
      изменения списка, операции в примерах 3 и 4 — это создание нового списка (в т.ч. при помощи среза
      существующего списка).
    </p>
    <h2>Рекурсивные функции</h2>
    <p>
      Рекурсией называется ситуация, когда функция вызывает сама себя (явным образом или косвенно).
      Классические примеры рекурсии в математике — определение факториала, чисел Фибоначчи.
    </p>
    <p>
      Знакомые с творчеством Станислава Лема наверняка помнят пример косвенной рекурсии из "&lt;Звёздных
      дневников Ийона Тихого"&gt;:
    </p>
    <p>
      <em>Нашёл следующие краткие сведения:
        <br>
        «СЕПУЛЬКИ — важный элемент цивилизации ардритов с планеты Энтеропия. См. СЕПУЛЬКАРИИ».
        <br>
        Я последовал этому совету и прочёл:
        <br>
        «СЕПУЛЬКАРИИ — устройства для сепуления (см.)».
        <br>
        Я поискал «Сепуление»; там значилось:
        <br>
        «СЕПУЛЕНИЕ — занятие ардритов (см.) с планеты Энтеропия (см.). См. СЕПУЛЬКИ».</em>
    </p>
    <p>
      При записи рекурсивных функций обычно решаются две задачи:
    </p>
    <ul>
      <li>определение значений аргумента, при которых рекурсивный вызов не требуется
      </li>
      <li>
        переход от вычисления функции при данном значении аргумента к вычислению функции от другого (как правило
        меньшего) значения.
      </li>
    </ul>
    <p>
      Примеры рекурсивных решений приведённых ранее задач и некоторых новых:
    </p>
    <pre class="python"># вычисление n-го числа Фибоначчи: F(1) = F(2) = 1, F(n) = F(n-1) + F(n-2)
def fibonacci(n):
    if n &lt;= 2:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)

# вычисление факториала
def factorial(n):
    if n == 0 or n == 1:
        return 1
    else:
        return n * factorial(n-1)

# алгоритм Евклида вычисления НОД
def gcd(a, b):
    if b == 0:
        return a
    else:
        return gcd(b, a % b)

# проверка строки на палиндром
def IsPalindrom(s):
    if len(s)&lt;=1: return True
    return s[0]==s[len(s)-1] and IsPalindrom(s[1:len(s)-1])

# подсчёт суммы цифр натурального числа
def sum_of_digits(n):
    if  n // 10 == 0:
        return n
    else:
        return n % 10 + sum_of_digits(n // 10)
</pre>
    <p>Рекурсивные программы почти всегда короче нерекурсивных, но не всегда эффективнее их. В качестве примера
      можно релизовать рекурсивную и нерекурсивную функции вычисления чисел Фибоначчи и сравнить время их работы
      при вычислении, например, <em>50</em>-го числа этой последовательности.</p>
    <h1></h1>

</body>

</html>